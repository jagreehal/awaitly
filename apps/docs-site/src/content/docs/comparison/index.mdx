---
title: Comparison Overview
description: Compare awaitly with try/catch, neverthrow, and Effect for error handling
sidebar:
  order: 0
---

import { Card, CardGrid } from '@astrojs/starlight/components';

Here's the thing about software: it fails. Not sometimes. **Always**.

The database takes a nap when you need it. The payment provider goes for coffee. The user types "banana" where you expected a number.

Most programmers treat errors like embarrassing relatives. They pretend they don't exist until they show up and ruin everything. But what if we treated errors as first-class citizens?

## Five Philosophies

| | |
|---|---|
| **Safety Net (try/catch)** | **Railway (neverthrow)** |
| Happy path first | Success track |
| Slip and fall | Switch point |
| Caught (maybe) | Error track |
| | |
| **Control Room (Effect)** | **Orchestrator (awaitly)** |
| Blueprint | Declare steps |
| Control panel | Auto-infer errors |
| Execute | Execute with step() |
| | |
| **Platform (Vercel Workflow)** | |
| "use step" directive | |
| Compiler transforms code | |
| Platform handles durability | |

## At a Glance

| Approach | Error Visibility | Composability | Ergonomics | Bundle Size |
|----------|-----------------|---------------|------------|-------------|
| **try/catch** | Low (hidden) | Medium | High | Minimal |
| **awaitly** | High | High | High | Light |
| **neverthrow** | High | High | Medium | Light |
| **Effect** | Very High | Very High | Low → Medium | Heavy |

## Three Criteria for Great Error Handling

Whatever approach you choose, evaluate it against these benchmarks:

1. **Visible**: Can you see all the ways your code can fail just by looking at it?
2. **Composable**: Do errors make it painful to combine functions together?
3. **Honest**: Do your function signatures tell the truth about what might happen?

## The Decision Tree

```text
Need to handle errors?
        │
        ▼
   Simple use case? ──Yes──▶ try/catch
        │
       No
        │
        ▼
Want compiler-verified error handling (Result types)?
        │
   No ──▶ try/catch
        │
   Yes
        │
        ▼
   Want async/await syntax? ──No──▶ neverthrow
        │
       Yes
        │
        ▼
   Need full ecosystem (DI, layers, tracing)?
        │
       Yes ──▶ Effect
        │
       No ──▶ awaitly
```

## When to Use What

### Start with try/catch if:
- You're building something simple
- You need to ship quickly
- You're at system boundaries (HTTP handlers, event listeners)

### Consider awaitly when:
- You want Result types with familiar async/await syntax
- You need automatic error type inference
- You need retries, timeouts, and caching
- You like Effect-style helpers (`step.run`, `step.andThen`, `step.match`, `step.all`, `step.map`) without the Effect runtime
- Your team knows async/await but wants better error handling

### Consider neverthrow when:
- You want compiler-verified error handling
- You prefer functional chaining (`.andThen()`)
- You don't mind moving away from async/await for composition

### Look at Effect when:
- You need the full ecosystem (DI, layers, tracing)
- Testability via pure dependency injection is critical
- Your team has capacity to learn functional programming

## Detailed Comparisons

<CardGrid>
  <Card title="vs Promises" icon="document">
    Compare Promise + try/catch with AsyncResult. See why typed errors catch bugs at compile time.

    [Read comparison →](/comparison/awaitly-vs-promise/)
  </Card>
  <Card title="vs try/catch" icon="warning">
    Compare traditional exception handling with Result types. See why explicit errors catch bugs at compile time.

    [Read comparison →](/comparison/awaitly-vs-try-catch/)
  </Card>
  <Card title="vs neverthrow" icon="rocket">
    Both use Result types. Compare chaining (`.andThen()`) vs async/await (`step()`).

    [Read comparison →](/comparison/awaitly-vs-neverthrow/)
  </Card>
  <Card title="vs Effect" icon="setting">
    Compare lightweight orchestration vs full ecosystem. Effect-style step helpers (run, andThen, match, all, map) with native async/await.

    [Read comparison →](/comparison/awaitly-vs-effect/)
  </Card>
  <Card title="Effect-style layers in awaitly" icon="layers">
    Effect-style dependency injection without Tags or Layers: pass deps when you create or run a workflow; override per run for tests.

    [Read guide →](/comparison/effect-layers-in-awaitly/)
  </Card>
  <Card title="vs Vercel Workflow" icon="external">
    Compare compiler directives with explicit Result types. See when platform integration beats portability.

    [Read comparison →](/comparison/awaitly-vs-workflow/)
  </Card>
</CardGrid>

## The Uncomfortable Truth

Errors aren't bugs, they're features. The difference between a junior and senior developer isn't bug-free code. It's designing around inevitable failure.

**There's no "correct" choice.** Each approach is a tool:
- Use **try/catch** when you need simplicity
- Use **neverthrow** when you need functional composition
- Use **awaitly** when you want familiar syntax with type safety
- Use **Effect** when you need the full architectural toolkit

But whatever you choose, **choose deliberately**. Your future self at 3 AM will thank you.
