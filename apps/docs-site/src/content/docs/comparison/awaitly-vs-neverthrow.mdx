---
title: awaitly vs neverthrow
description: A comparison of awaitly and neverthrow for Result-based error handling
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

Both awaitly and [neverthrow](https://github.com/supermacro/neverthrow) provide Result types for TypeScript. This guide compares their APIs and helps you choose the right tool.

## Quick Comparison

| Feature | awaitly | neverthrow |
|---------|---------|------------|
| Result type | `Result<T, E>` | `Result<T, E>` |
| Async result | `AsyncResult<T, E>` | `ResultAsync<T, E>` |
| Method style | Functions | Methods |
| Workflow orchestration | Built-in | Not included |
| Automatic error inference | Yes | No |

## Creating Results

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, err } from 'awaitly';

const divide = (a: number, b: number) =>
  b === 0 ? err('DIVIDE_BY_ZERO') : ok(a / b);

const result = divide(10, 2);
/*
Output:
{ ok: true, value: 5 }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok, err } from 'neverthrow';

const divide = (a: number, b: number) =>
  b === 0 ? err('DIVIDE_BY_ZERO') : ok(a / b);

const result = divide(10, 2);
/*
Output:
Result { _value: 5 }
*/
```
  </TabItem>
</Tabs>

<Aside type="note">
Both libraries use the same `ok()` and `err()` constructors, making migration straightforward.
</Aside>

## Checking Results

<Tabs>
  <TabItem label="awaitly">
```typescript
import { isOk, isErr } from 'awaitly';

const result = divide(10, 2);

// Property-based
if (result.ok) {
  console.log(result.value); // 5
}

// Function-based
if (isOk(result)) {
  console.log(result.value); // 5
}
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
const result = divide(10, 2);

// Method-based
if (result.isOk()) {
  console.log(result.value); // 5
}

if (result.isErr()) {
  console.log(result.error);
}
```
  </TabItem>
</Tabs>

## Transforming Values

### map

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, map } from 'awaitly';

const result = ok(5);
const doubled = map(result, n => n * 2);
/*
Output:
{ ok: true, value: 10 }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok } from 'neverthrow';

const result = ok(5);
const doubled = result.map(n => n * 2);
/*
Output:
Result { _value: 10 }
*/
```
  </TabItem>
</Tabs>

### mapError

<Tabs>
  <TabItem label="awaitly">
```typescript
import { err, mapError } from 'awaitly';

const result = err('NOT_FOUND');
const mapped = mapError(result, e => ({ code: e, status: 404 }));
/*
Output:
{ ok: false, error: { code: 'NOT_FOUND', status: 404 } }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { err } from 'neverthrow';

const result = err('NOT_FOUND');
const mapped = result.mapErr(e => ({ code: e, status: 404 }));
/*
Output:
Result { _error: { code: 'NOT_FOUND', status: 404 } }
*/
```
  </TabItem>
</Tabs>

## Chaining Operations

### andThen / flatMap

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, err, andThen } from 'awaitly';

const parseNumber = (s: string) => {
  const n = parseInt(s, 10);
  return isNaN(n) ? err('PARSE_ERROR') : ok(n);
};

const result = ok('42');
const parsed = andThen(result, parseNumber);
/*
Output:
{ ok: true, value: 42 }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok, err } from 'neverthrow';

const parseNumber = (s: string) => {
  const n = parseInt(s, 10);
  return isNaN(n) ? err('PARSE_ERROR') : ok(n);
};

const result = ok('42');
const parsed = result.andThen(parseNumber);
/*
Output:
Result { _value: 42 }
*/
```
  </TabItem>
</Tabs>

## Pattern Matching

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, match } from 'awaitly';

const result = ok(42);
const message = match(
  result,
  value => `Success: ${value}`,
  error => `Error: ${error}`
);
/*
Output:
"Success: 42"
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok } from 'neverthrow';

const result = ok(42);
const message = result.match(
  value => `Success: ${value}`,
  error => `Error: ${error}`
);
/*
Output:
"Success: 42"
*/
```
  </TabItem>
</Tabs>

## Async Operations

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, err, type AsyncResult } from 'awaitly';

const fetchUser = async (id: string): AsyncResult<User, 'NOT_FOUND'> => {
  const user = await db.find(id);
  return user ? ok(user) : err('NOT_FOUND');
};

// Use with regular async/await
const result = await fetchUser('123');
if (result.ok) {
  console.log(result.value.name);
}
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { okAsync, errAsync, ResultAsync } from 'neverthrow';

const fetchUser = (id: string): ResultAsync<User, 'NOT_FOUND'> => {
  return ResultAsync.fromPromise(
    db.find(id),
    () => 'NOT_FOUND' as const
  );
};

// Chain with methods
const result = await fetchUser('123');
if (result.isOk()) {
  console.log(result.value.name);
}
```
  </TabItem>
</Tabs>

## Batch Operations

### Combining Multiple Results

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, err, all } from 'awaitly';

const results = [ok(1), ok(2), ok(3)];
const combined = all(results);
/*
Output:
{ ok: true, value: [1, 2, 3] }
*/

const withError = [ok(1), err('FAILED'), ok(3)];
const failed = all(withError);
/*
Output:
{ ok: false, error: 'FAILED' }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok, err, Result } from 'neverthrow';

const results = [ok(1), ok(2), ok(3)];
const combined = Result.combine(results);
/*
Output:
Result { _value: [1, 2, 3] }
*/

const withError = [ok(1), err('FAILED'), ok(3)];
const failed = Result.combine(withError);
/*
Output:
Result { _error: 'FAILED' }
*/
```
  </TabItem>
</Tabs>

## Unwrapping

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, unwrap, unwrapOr, unwrapOrElse } from 'awaitly';

const result = ok(42);

// Throws if err
const value1 = unwrap(result); // 42

// Default value
const value2 = unwrapOr(result, 0); // 42

// Computed default
const value3 = unwrapOrElse(result, err => {
  console.log('Failed:', err);
  return 0;
}); // 42
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok } from 'neverthrow';

const result = ok(42);

// Throws if err
const value1 = result.unwrapOr(0); // neverthrow doesn't have unwrap()

// Default value
const value2 = result.unwrapOr(0); // 42

// neverthrow doesn't have unwrapOrElse
```
  </TabItem>
</Tabs>

## Async Chaining

### asyncAndThen

Chain a sync Result into an async operation.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, andThen, type AsyncResult } from 'awaitly';

const parseId = (s: string) => {
  const n = parseInt(s, 10);
  return isNaN(n) ? err('PARSE_ERROR') : ok(n);
};

const fetchUser = async (id: number): AsyncResult<User, 'NOT_FOUND'> => {
  const user = await db.find(id);
  return user ? ok(user) : err('NOT_FOUND');
};

// Just use async function - awaitly handles sync→async naturally
const result = await andThen(parseId('42'), fetchUser);
/*
Output:
{ ok: true, value: { id: 42, name: 'Alice' } }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok, err } from 'neverthrow';

const parseId = (s: string) => {
  const n = parseInt(s, 10);
  return isNaN(n) ? err('PARSE_ERROR' as const) : ok(n);
};

const fetchUser = (id: number) =>
  ResultAsync.fromPromise(db.find(id), () => 'NOT_FOUND' as const);

// Use asyncAndThen to chain sync Result → ResultAsync
const result = await parseId('42').asyncAndThen(fetchUser);
/*
Output:
Result { _value: { id: 42, name: 'Alice' } }
*/
```
  </TabItem>
</Tabs>

<Aside type="note">
In awaitly, `andThen` works with both sync and async functions. neverthrow has separate `andThen` (sync) and `asyncAndThen` (async) methods.
</Aside>

### asyncMap

Transform the success value with an async function.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, map } from 'awaitly';

const result = ok(42);

// map works with async functions
const enriched = await map(result, async (n) => {
  const data = await fetchMetadata(n);
  return { value: n, metadata: data };
});
/*
Output:
{ ok: true, value: { value: 42, metadata: {...} } }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok } from 'neverthrow';

const result = ok(42);

// Use asyncMap for async transformations
const enriched = await result.asyncMap(async (n) => {
  const data = await fetchMetadata(n);
  return { value: n, metadata: data };
});
/*
Output:
Result { _value: { value: 42, metadata: {...} } }
*/
```
  </TabItem>
</Tabs>

## Error Recovery

### orElse

Provide a fallback Result on failure.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { err, ok, orElse } from 'awaitly';

const result = err('NOT_FOUND');
const recovered = orElse(result, (e) => ok({ fallback: true, reason: e }));
/*
Output:
{ ok: true, value: { fallback: true, reason: 'NOT_FOUND' } }
*/

// Can also return a different error
const retyped = orElse(result, () => err('FALLBACK_FAILED'));
/*
Output:
{ ok: false, error: 'FALLBACK_FAILED' }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { err, ok } from 'neverthrow';

const result = err('NOT_FOUND');
const recovered = result.orElse((e) => ok({ fallback: true, reason: e }));
/*
Output:
Result { _value: { fallback: true, reason: 'NOT_FOUND' } }
*/

// Can also return a different error
const retyped = result.orElse(() => err('FALLBACK_FAILED'));
/*
Output:
Result { _error: 'FALLBACK_FAILED' }
*/
```
  </TabItem>
</Tabs>

## Collecting All Errors

### combineWithAllErrors

Collect ALL errors instead of failing on the first one.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { ok, err, allSettled } from 'awaitly';

const results = [ok(1), err('ERROR_A'), ok(3), err('ERROR_B')];
const settled = allSettled(results);
/*
Output:
{
  ok: false,
  error: ['ERROR_A', 'ERROR_B'],
  successes: [1, 3],
  failures: ['ERROR_A', 'ERROR_B']
}
*/

// For fail-fast behavior, use all() instead
const failFast = all(results);
/*
Output:
{ ok: false, error: 'ERROR_A' }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { ok, err, Result } from 'neverthrow';

const results = [ok(1), err('ERROR_A'), ok(3), err('ERROR_B')];
const combined = Result.combineWithAllErrors(results);
/*
Output:
Result { _error: ['ERROR_A', 'ERROR_B'] }
*/

// For fail-fast behavior, use combine() instead
const failFast = Result.combine(results);
/*
Output:
Result { _error: 'ERROR_A' }
*/
```
  </TabItem>
</Tabs>

<Aside type="note">
awaitly's `allSettled` provides both errors and successes in the result, giving you more information to work with.
</Aside>

## Wrapping Throwing Functions

### fromThrowable / tryCatch

Safely wrap functions that might throw exceptions.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { tryCatch } from 'awaitly';

// Wrap a throwing function
const parseJson = (s: string) =>
  tryCatch(
    () => JSON.parse(s),
    (e) => ({ type: 'PARSE_ERROR' as const, message: String(e) })
  );

const valid = parseJson('{"name": "Alice"}');
/*
Output:
{ ok: true, value: { name: 'Alice' } }
*/

const invalid = parseJson('not json');
/*
Output:
{ ok: false, error: { type: 'PARSE_ERROR', message: '...' } }
*/
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { Result } from 'neverthrow';

// Create a safe version of a throwing function
const safeJsonParse = Result.fromThrowable(
  JSON.parse,
  (e) => ({ type: 'PARSE_ERROR' as const, message: String(e) })
);

const valid = safeJsonParse('{"name": "Alice"}');
/*
Output:
Result { _value: { name: 'Alice' } }
*/

const invalid = safeJsonParse('not json');
/*
Output:
Result { _error: { type: 'PARSE_ERROR', message: '...' } }
*/
```
  </TabItem>
</Tabs>

<Aside type="note">
`tryCatch` executes immediately and returns a Result. neverthrow's `fromThrowable` returns a new function that you then call.
</Aside>

## Generator-Based Composition

### safeTry / Generators

neverthrow provides `safeTry` for generator-based composition. awaitly uses standard async/await instead.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { createWorkflow } from 'awaitly/workflow';

// awaitly uses familiar async/await - no generators needed
const workflow = createWorkflow({ parseId, fetchUser, sendEmail });

const result = await workflow(async (step) => {
  const id = await step(parseId('42'));
  const user = await step(fetchUser(id));
  await step(sendEmail(user.email));
  return user;
});

// Errors short-circuit automatically, no special syntax required
```
  </TabItem>
  <TabItem label="neverthrow">
```typescript
import { safeTry, ok, err } from 'neverthrow';

// neverthrow uses generators for imperative-style composition
const result = safeTry(function* () {
  const id = yield* parseId('42').safeUnwrap();
  const user = yield* fetchUser(id).safeUnwrap();
  yield* sendEmail(user.email).safeUnwrap();
  return ok(user);
});

// Errors short-circuit via generator yield
```
  </TabItem>
</Tabs>

<Aside type="tip" title="Why async/await?">
awaitly chose async/await over generators because:
- Most TypeScript developers already know async/await
- Better IDE support and debugging experience
- No special `.safeUnwrap()` method needed
- Works naturally with existing async code
</Aside>

## What awaitly Adds: Workflow Orchestration

<Aside type="tip" title="awaitly's Key Advantage">
While neverthrow focuses purely on Result types, awaitly adds workflow orchestration with automatic error inference.
</Aside>

### Automatic Error Type Inference

```typescript
import { ok, err, type AsyncResult } from 'awaitly';
import { createWorkflow } from 'awaitly/workflow';

const fetchUser = async (id: string): AsyncResult<User, 'NOT_FOUND'> => { /* ... */ };
const sendEmail = async (to: string): AsyncResult<void, 'EMAIL_FAILED'> => { /* ... */ };
const chargeCard = async (amount: number): AsyncResult<Receipt, 'PAYMENT_DECLINED'> => { /* ... */ };

// Error types automatically inferred from all dependencies
const workflow = createWorkflow({ fetchUser, sendEmail, chargeCard });

const result = await workflow(async (step) => {
  const user = await step(fetchUser('123'));
  await step(chargeCard(99.99));
  await step(sendEmail(user.email));
  return user;
});

// result.error is: 'NOT_FOUND' | 'EMAIL_FAILED' | 'PAYMENT_DECLINED' | UnexpectedError
//                  ^^^ Automatically inferred from dependencies!
```

### Built-in Retry and Timeout

```typescript
const result = await workflow(async (step) => {
  // Retry with exponential backoff
  const user = await step.retry(
    () => fetchUser('123'),
    { attempts: 3, backoff: 'exponential', delayMs: 100 }
  );

  // Timeout protection
  const data = await step.withTimeout(
    () => slowOperation(),
    { ms: 5000 }
  );

  return { user, data };
});
```

### Step Caching and Resume

```typescript
// Option 1: In-memory (simple)
const workflow = createWorkflow(deps, {
  cache: new Map(),
  resumeState: savedState, // Resume from previous run
});

// Option 2: Snapshot store (awaitly-mongo or awaitly-postgres)
import { mongo } from 'awaitly-mongo';
// or: import { postgres } from 'awaitly-postgres';

const store = mongo(process.env.MONGODB_URI!);

const workflow = createWorkflow(deps, {
  snapshot: await store.load('wf-1'), // Resume from saved snapshot (or null)
});

const result = await workflow(async (step) => {
  const user = await step(() => fetchUser('1'), { key: 'user:1' });
  return user;
});
await store.save('wf-1', workflow.getSnapshot());
```

## When to Choose Each

### Choose awaitly when:
- You want Result types with familiar async/await syntax
- You need workflow orchestration (retries, timeouts, caching)
- You want automatic error type inference
- You're building multi-step async operations
- You need step-level resilience patterns
- You want to keep async/await ergonomics for multi-step flows

### Choose neverthrow when:
- You only need Result types without workflow features
- You prefer method chaining over function calls
- You want the smallest possible bundle size
- Your project already uses neverthrow

## Method Chaining vs Functions

```typescript
// neverthrow: method chaining
import { ok, err } from 'neverthrow';
const result = ok(5).map(n => n * 2).mapErr(e => e.toUpperCase());

// awaitly: standalone functions
import { ok, err, map, mapError } from 'awaitly';
const result = mapError(map(ok(5), n => n * 2), e => e.toUpperCase());

// Or use pipe pattern with R namespace
import { pipe, R } from 'awaitly/functional';
const result = pipe(
  ok(5),
  R.map(n => n * 2),
  R.mapError(e => e.toUpperCase())
);
```

<Aside type="note">
awaitly uses standalone functions instead of methods, which works better with tree-shaking and functional composition. See [Functional Utilities](/guides/functional-utilities/) for pipe-based composition patterns.
</Aside>

## Next Steps

- [Learn about Workflows →](/foundations/workflows/)
- [See the full API Reference →](/reference/api/)
