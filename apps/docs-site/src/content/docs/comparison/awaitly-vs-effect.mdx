---
title: awaitly vs Effect
description: Comparing awaitly with Effect for typed async workflows
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

[Effect](https://effect.website/) is a powerful functional programming library for TypeScript. awaitly provides a simpler alternative for teams that want Result types and workflow orchestration without Effect's full complexity.

## Philosophy Comparison

```text
Effect                              awaitly
┌─────────────────────────┐         ┌──────────────────────────┐
│  Full functional system │         │  Pragmatic Result types  │
│  ────────────────────── │         │  ──────────────────────  │
│  • Fibers & concurrency │         │  • Simple async/await    │
│  • Dependency injection │         │  • Workflow orchestration│
│  • Scheduling & limiting│         │  • Retry/timeout/limits  │
│  • Resource management  │         │  • Automatic error union │
│  • Comprehensive stdlib │         │  • Minimal API surface   │
└─────────────────────────┘         └──────────────────────────┘
```

<Aside type="tip" title="When to choose awaitly">
Choose awaitly when you want typed error handling and workflow resilience without adopting a full functional paradigm.
</Aside>

## Quick Comparison

| Feature | awaitly | Effect |
|---------|---------|--------|
| Learning curve | Low | Steep |
| Bundle size | Light (tree-shakeable) | Heavy |
| Result type | `Result<T, E>` | `Effect<A, E, R>` |
| Error tracking | Automatic inference | Explicit typing |
| Async model | Native Promises | Effect runtime |
| Dependency injection | Simple context | Full DI system |
| Scheduling | Retry policies | Schedule combinators |
| Concurrency | Native Promise.all | Fibers |
| Rate limiting | Built-in `awaitly/ratelimit` | Built-in `RateLimiter` |

## Result Types

### Creating Results

<Tabs>
  <TabItem label="awaitly">
```typescript
import { Awaitly, type Result } from 'awaitly';

const divide = (a: number, b: number): Result<number, 'DIVIDE_BY_ZERO'> =>
  b === 0 ? Awaitly.err('DIVIDE_BY_ZERO') : Awaitly.ok(a / b);

const result = divide(10, 2);
if (result.ok) {
  console.log(result.value);
}
/*
Output:
5
*/
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect } from 'effect';

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.fail('DIVIDE_BY_ZERO' as const)
    : Effect.succeed(a / b);

// Must run through Effect runtime
const program = divide(10, 2);
Effect.runSync(program); // 5
```
  </TabItem>
</Tabs>

### Type Structure

```text
awaitly Result:
         ┌─── Success value type
         │       ┌─── Error type
         ▼       ▼
Result<number, 'DIVIDE_BY_ZERO'>

Effect:
         ┌─── Success value
         │     ┌─── Error type
         │     │     ┌─── Requirements (dependencies)
         ▼     ▼     ▼
Effect<number, 'DIVIDE_BY_ZERO', never>
```

<Aside type="note">
Effect has a third type parameter for dependencies (Requirements). awaitly handles dependencies through `createWorkflow`.
</Aside>

## Error Handling

### Error Type Inference

<Tabs>
  <TabItem label="awaitly">
```typescript
import { createWorkflow } from 'awaitly/workflow';

const fetchUser = async (id: string): AsyncResult<User, 'NOT_FOUND'> => { /* ... */ };
const sendEmail = async (to: string): AsyncResult<void, 'EMAIL_FAILED'> => { /* ... */ };

// Error types automatically inferred from dependencies
const workflow = createWorkflow('workflow', { fetchUser, sendEmail });

const result = await workflow(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'));
  await step('sendEmail', () => sendEmail(user.email));
  return user;
});

// TypeScript knows: result.error is 'NOT_FOUND' | 'EMAIL_FAILED' | UnexpectedError
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect, pipe } from 'effect';

const fetchUser = (id: string) =>
  Effect.fail('NOT_FOUND' as const).pipe(
    Effect.map(() => ({ id, email: 'user@example.com' }))
  );

const sendEmail = (to: string) =>
  Effect.fail('EMAIL_FAILED' as const).pipe(
    Effect.map(() => undefined)
  );

// Must compose effects explicitly
const program = pipe(
  fetchUser('1'),
  Effect.flatMap(user =>
    pipe(
      sendEmail(user.email),
      Effect.map(() => user)
    )
  )
);

// TypeScript knows: E = 'NOT_FOUND' | 'EMAIL_FAILED'
```
  </TabItem>
</Tabs>

### Catching Errors

<Tabs>
  <TabItem label="awaitly">
```typescript
const result = await workflow(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'));
  return user;
});

if (!result.ok) {
  switch (result.error) {
    case 'NOT_FOUND':
      console.log('User not found');
      break;
    case 'EMAIL_FAILED':
      console.log('Email failed');
      break;
  }
}
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect } from 'effect';

const handled = program.pipe(
  Effect.catchTag('NOT_FOUND', () =>
    Effect.succeed({ fallback: true })
  ),
  Effect.catchTag('EMAIL_FAILED', () =>
    Effect.succeed({ emailSkipped: true })
  )
);
```
  </TabItem>
</Tabs>

## Retry and Scheduling

awaitly uses retry policies while Effect uses Schedule combinators. Both achieve similar outcomes with different approaches.

### Basic Retry

<Tabs>
  <TabItem label="awaitly">
```typescript
const result = await workflow(async (step) => {
  const data = await step.retry(
    'fetchData',
    () => fetchData(),
    {
      attempts: 3,
      backoff: 'exponential',
      delayMs: 100,
    }
  );
  return data;
});
/*
Retry timeline:
Attempt 1: immediate
Attempt 2: after 100ms
Attempt 3: after 200ms
*/
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect, Schedule } from 'effect';

const policy = Schedule.exponential('100 millis').pipe(
  Schedule.compose(Schedule.recurs(3))
);

const program = fetchData.pipe(
  Effect.retry(policy)
);

Effect.runPromise(program);
```
  </TabItem>
</Tabs>

### Backoff Visualization

```text
awaitly Exponential Backoff (delayMs: 100)
────────────────────────────────────────────
#1: 100ms   ████
#2: 200ms   ████████
#3: 400ms   ████████████████
#4: 800ms   ████████████████████████████████
```

### With Timeout

<Tabs>
  <TabItem label="awaitly">
```typescript
const result = await workflow(async (step) => {
  const data = await step.retry(
    'fetchData',
    () => step.withTimeout(
      'fetchData',
      () => fetchData(),
      { ms: 5000 }
    ),
    { attempts: 3, backoff: 'exponential', delayMs: 100 }
  );
  return data;
});
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect, Schedule, Duration } from 'effect';

const policy = Schedule.exponential('100 millis').pipe(
  Schedule.compose(Schedule.recurs(3))
);

const program = fetchData.pipe(
  Effect.timeout(Duration.seconds(5)),
  Effect.retry(policy)
);
```
  </TabItem>
</Tabs>

### With Jitter

<Tabs>
  <TabItem label="awaitly">
```typescript
const result = await step.retry(
  'fetchData',
  () => fetchData(),
  {
    attempts: 5,
    backoff: 'exponential',
    delayMs: 100,
    jitter: true, // Adds random variation
  }
);
```
  </TabItem>
  <TabItem label="Effect">
```typescript
const policy = Schedule.exponential('100 millis').pipe(
  Schedule.jittered,
  Schedule.compose(Schedule.recurs(5))
);
```
  </TabItem>
</Tabs>

### Rate Limiting

<Tabs>
  <TabItem label="awaitly">
```typescript
import { createRateLimiter } from 'awaitly/ratelimit';

const limiter = createRateLimiter('api', {
  maxPerSecond: 2,
  burstCapacity: 5,
});

const result = await workflow(async (step) => {
  // Rate limit *when the step starts*
  const data = await limiter.execute(() => step('fetchData', () => fetchData()));
  return data;
});
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect, RateLimiter } from 'effect';

// fetchData: Effect<Data, Error, never>
const program = Effect.scoped(
  Effect.gen(function* (_) {
    const rateLimit = yield* _(
      RateLimiter.make({ limit: 2, interval: '1 seconds' })
    );
    return yield* _(rateLimit(fetchData));
  })
);
```
  </TabItem>
</Tabs>

<Aside type="note">
Both libraries can rate limit by start-time. awaitly also includes a separate concurrency limiter (max in-flight + optional queue) via `createConcurrencyLimiter`.
</Aside>

## Workflow Orchestration

### Multi-step Workflows

<Tabs>
  <TabItem label="awaitly">
```typescript
import { createWorkflow } from 'awaitly/workflow';

const workflow = createWorkflow('workflow', { fetchUser,
  validateOrder,
  chargeCard,
  sendConfirmation,
});

const result = await workflow(async (step) => {
  const user = await step('fetchUser', () => fetchUser(userId));
  const order = await step('validateOrder', () => validateOrder(orderData));
  const receipt = await step('chargeCard', () => chargeCard(order.total));
  await step('sendConfirmation', () => sendConfirmation(user.email, receipt));
  return { user, order, receipt };
});
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect, pipe } from 'effect';

const program = pipe(
  fetchUser(userId),
  Effect.flatMap(user =>
    pipe(
      validateOrder(orderData),
      Effect.flatMap(order =>
        pipe(
          chargeCard(order.total),
          Effect.flatMap(receipt =>
            pipe(
              sendConfirmation(user.email, receipt),
              Effect.map(() => ({ user, order, receipt }))
            )
          )
        )
      )
    )
  )
);

// Or with Effect.gen (generator syntax)
const program = Effect.gen(function* () {
  const user = yield* fetchUser(userId);
  const order = yield* validateOrder(orderData);
  const receipt = yield* chargeCard(order.total);
  yield* sendConfirmation(user.email, receipt);
  return { user, order, receipt };
});
```
  </TabItem>
</Tabs>

### Parallel Operations

<Tabs>
  <TabItem label="awaitly">
```typescript
import { Awaitly } from 'awaitly';

const result = await workflow(async (step) => {
  const [user, posts, comments] = await step('fetchUserData', () =>
    Awaitly.allAsync([
      fetchUser('1'),
      fetchPosts('1'),
      fetchComments('1'),
    ])
  );
  return { user, posts, comments };
});
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect } from 'effect';

const program = Effect.all([
  fetchUser('1'),
  fetchPosts('1'),
  fetchComments('1'),
], { concurrency: 'unbounded' });
```
  </TabItem>
</Tabs>

## Caching and Persistence

<Tabs>
  <TabItem label="awaitly">
```typescript
// Option 1: In-memory (simple)
const workflow = createWorkflow('workflow', deps, {
  cache: new Map(),
  resumeState: savedState, // Resume from previous run
});

// Option 2: Snapshot store (awaitly-mongo or awaitly-postgres)
import { mongo } from 'awaitly-mongo';
// or: import { postgres } from 'awaitly-postgres';

const store = mongo(process.env.MONGODB_URI!);

const workflow = createWorkflow('workflow', deps, {
  snapshot: await store.load('wf-1'), // Resume from saved snapshot (or null)
});

const result = await workflow(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'), { key: 'user:1' });
  return user;
});
await store.save('wf-1', workflow.getSnapshot());
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect, Cache, Duration } from 'effect';

const cache = Cache.make({
  capacity: 100,
  timeToLive: Duration.minutes(5),
  lookup: (key: string) => fetchUser(key),
});

const program = Effect.gen(function* () {
  const c = yield* cache;
  return yield* c.get('1');
});
```
  </TabItem>
</Tabs>

## Combining Results

Both libraries provide ways to combine multiple Results/Effects.

### All (Fail-Fast)

<Tabs>
  <TabItem label="awaitly">
```typescript
import { Awaitly } from 'awaitly';

// Sync results
const results = [Awaitly.ok(1), Awaitly.ok(2), Awaitly.ok(3)];
const combined = Awaitly.all(results);
/*
Output:
{ ok: true, value: [1, 2, 3] }
*/

// Async results
const asyncResults = await Awaitly.allAsync([
  fetchUser('1'),
  fetchUser('2'),
  fetchUser('3'),
]);
/*
Output:
{ ok: true, value: [user1, user2, user3] }
or
{ ok: false, error: 'NOT_FOUND' } // first error
*/
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect } from 'effect';

// Effect.all combines multiple effects
const program = Effect.all([
  fetchUser('1'),
  fetchUser('2'),
  fetchUser('3'),
]);

// Run with unbounded concurrency
const result = await Effect.runPromise(
  program.pipe(Effect.withConcurrency('unbounded'))
);
```
  </TabItem>
</Tabs>

### AllSettled (Collect All Errors)

<Tabs>
  <TabItem label="awaitly">
```typescript
import { Awaitly } from 'awaitly';

const results = [Awaitly.ok(1), Awaitly.err('A'), Awaitly.ok(3), Awaitly.err('B')];
const settled = Awaitly.allSettled(results);
/*
Output:
{
  ok: false,
  error: ['A', 'B'],
  successes: [1, 3],
  failures: ['A', 'B']
}
*/
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect } from 'effect';

// Use Effect.allSettled or partition
const program = Effect.forEach(
  [fetchUser('1'), fetchUser('2')],
  (effect) => Effect.either(effect)
);

// Returns array of Either<E, A>
```
  </TabItem>
</Tabs>

## Resource Management

Effect has a sophisticated resource management system with `Scope` and `Resource`. awaitly uses standard JavaScript patterns.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { createWorkflow } from 'awaitly/workflow';

// awaitly uses standard try/finally patterns
const workflow = createWorkflow('workflow', { openConnection, query });

const result = await workflow(async (step) => {
  const conn = await step('openConnection', () => openConnection());
  try {
    const data = await step('query', () => query(conn, 'SELECT * FROM users'));
    return data;
  } finally {
    await conn.close(); // Standard cleanup
  }
});

// Or use the using keyword (TC39 Explicit Resource Management)
const result = await workflow(async (step) => {
  using conn = await step('openConnection', () => openConnection());
  const data = await step('query', () => query(conn, 'SELECT * FROM users'));
  return data;
}); // conn.close() called automatically
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Effect, Scope } from 'effect';

// Effect has built-in resource management
const program = Effect.scoped(
  Effect.gen(function* () {
    const conn = yield* openConnection;
    const data = yield* query(conn, 'SELECT * FROM users');
    return data;
  }) // conn automatically closed when scope exits
);
```
  </TabItem>
</Tabs>

<Aside type="note">
Effect's `Scope` system provides automatic cleanup and composition of resources. awaitly relies on JavaScript's native patterns (`try/finally`, `using` statement) which are simpler but less composable.
</Aside>

## Streaming

Both libraries support streaming data processing.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { streamAsync, collectAsync } from 'awaitly/streaming';

// Process items as a stream with error handling
const stream = streamAsync(fetchPaginatedUsers(), {
  transform: (user) => enrichUser(user),
  onError: (e) => console.error('Stream error:', e),
});

// Collect results
const result = await collectAsync(stream);
/*
Output:
{ ok: true, value: [enrichedUser1, enrichedUser2, ...] }
*/

// Or process one at a time
for await (const item of stream) {
  if (!item.ok) {
    console.error(item.error);
    continue;
  }
  await processUser(item.value);
}
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { Stream, Effect } from 'effect';

// Effect has a full Stream module
const stream = Stream.fromIterable(fetchPaginatedUsers()).pipe(
  Stream.mapEffect((user) => enrichUser(user)),
  Stream.catchAll((e) => {
    console.error('Stream error:', e);
    return Stream.empty;
  })
);

// Run the stream
const result = await Effect.runPromise(
  Stream.runCollect(stream)
);
```
  </TabItem>
</Tabs>

<Aside type="tip">
Effect's Stream is more powerful (backpressure, chunking, advanced combinators). awaitly's streaming is simpler and wraps async iterables with Result types. Choose based on your complexity needs.
</Aside>

## Functional Utilities

Both libraries provide functional composition utilities.

<Tabs>
  <TabItem label="awaitly">
```typescript
import { Awaitly } from 'awaitly';

// pipe: Apply functions left-to-right to a value
const result = Awaitly.pipe(
  Awaitly.ok(5),
  Awaitly.R.map(n => n * 2),
  Awaitly.R.andThen(n => n > 5 ? Awaitly.ok(n) : Awaitly.err('TOO_SMALL')),
  Awaitly.R.mapError(e => ({ code: e }))
);

// flow: Create a new function from composed functions
const processNumber = Awaitly.flow(
  Awaitly.R.map((n: number) => n * 2),
  Awaitly.R.andThen(n => n > 5 ? Awaitly.ok(n) : Awaitly.err('TOO_SMALL')),
  Awaitly.R.mapError(e => ({ code: e }))
);

const result = processNumber(Awaitly.ok(5));
```
  </TabItem>
  <TabItem label="Effect">
```typescript
import { pipe, flow, Effect } from 'effect';

// pipe: Apply functions left-to-right to a value
const result = pipe(
  Effect.succeed(5),
  Effect.map(n => n * 2),
  Effect.flatMap(n => n > 5 ? Effect.succeed(n) : Effect.fail('TOO_SMALL')),
  Effect.mapError(e => ({ code: e }))
);

// flow: Create a new function from composed functions
const processNumber = flow(
  Effect.map((n: number) => n * 2),
  Effect.flatMap(n => n > 5 ? Effect.succeed(n) : Effect.fail('TOO_SMALL')),
  Effect.mapError(e => ({ code: e }))
);

const result = processNumber(Effect.succeed(5));
```
  </TabItem>
</Tabs>

<Aside type="note">
Both libraries use similar `pipe` and `flow` patterns. Effect's functional utilities are more extensive (includes `identity`, `constVoid`, `absurd`, etc.). awaitly's are focused on Result manipulation.
</Aside>

## When to Choose Each

### Choose awaitly when:

- **Gradual adoption**: You want to add Result types incrementally
- **Team familiarity**: Your team is comfortable with async/await
- **Simpler mental model**: You don't need fibers, layers, or advanced FP
- **Workflow focus**: Your main need is step orchestration with resilience
- **Bundle size matters**: You need a lightweight solution (~3KB vs ~50KB+)

### Choose Effect when:

- **Full FP paradigm**: You want a complete functional programming system
- **Advanced concurrency**: You need fibers and structured concurrency
- **Complex DI**: You need the Layer system for dependency injection
- **Rich scheduling**: You need composable Schedule types
- **Comprehensive stdlib**: You want Effect's extensive standard library

## Comparison Summary

```text
┌─────────────────────────────────────────────────────────────┐
│                    Complexity Spectrum                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  try/catch ──────► awaitly ──────────────────► Effect       │
│                                                             │
│  Simple           Pragmatic Result types     Full FP system │
│  No type safety   + workflow orchestration   + everything   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

<Aside type="tip" title="Migration Path">
awaitly can serve as a stepping stone. If you later need Effect's advanced features, the Result type concepts transfer directly.
</Aside>

## Next Steps

- [Getting Started with awaitly →](/getting-started/installation/)
- [Workflows in depth →](/foundations/workflows/)
- [Retries & Timeouts →](/guides/retries-timeouts/)
