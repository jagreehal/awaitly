---
title: Results
description: The Result type and how to work with it
---

import { Aside } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';

A `Result<T, E>` represents either success (`ok`) or failure (`err`). It replaces try/catch with explicit typing.

## Type Structure

```text
         ┌─── The success value type
         │       ┌─── The error type
         ▼       ▼
Result<Value, Error>

Examples:
Result<number, 'DIVIDE_BY_ZERO'>      → number on success, 'DIVIDE_BY_ZERO' on failure
Result<User, 'NOT_FOUND'>             → User on success, 'NOT_FOUND' on failure
Result<Order, 'INVALID' | 'EXPIRED'>  → Order on success, one of two errors on failure
```

## Creating Results

```typescript
import { ok, err, type AsyncResult } from 'awaitly';

// Synchronous
const divide = (a: number, b: number): Result<number, 'DIVIDE_BY_ZERO'> =>
  b === 0 ? err('DIVIDE_BY_ZERO') : ok(a / b);

// Asynchronous
const fetchUser = async (id: string): AsyncResult<User, 'NOT_FOUND'> => {
  const user = await db.users.find(id);
  return user ? ok(user) : err('NOT_FOUND');
};
```

<Aside type="tip" title="AsyncResult vs Promise">
`AsyncResult<T, E>` is just `Promise<Result<T, E>>`. Use it to make async function signatures cleaner.
</Aside>

## Checking Results

```typescript
const result = divide(10, 2);

if (result.ok) {
  console.log(result.value);
} else {
  console.log(result.error);
}
/*
Output:
5
*/
```

After checking `result.ok`, TypeScript narrows the type:
- If `result.ok` is `true`, you can access `result.value`
- If `result.ok` is `false`, you can access `result.error`

## Type guards

```typescript
import { isOk, isErr } from 'awaitly';

const result = divide(10, 0);

if (isOk(result)) {
  console.log(result.value);
}

if (isErr(result)) {
  console.log(result.error);
}
/*
Output:
DIVIDE_BY_ZERO
*/
```

## Transforming Results

### map - transform the value

```typescript
import { map } from 'awaitly';

const result = ok(5);
const doubled = map(result, (n) => n * 2);
/*
Output:
{ ok: true, value: 10 }
*/
```

<Aside type="note">
`map` only runs the function if the Result is `ok`. If it's `err`, the error passes through unchanged.
</Aside>

### mapError - transform the error

```typescript
import { mapError } from 'awaitly';

const result = err('NOT_FOUND');
const mapped = mapError(result, (e) => ({ type: e, status: 404 }));
/*
Output:
{ ok: false, error: { type: 'NOT_FOUND', status: 404 } }
*/
```

### andThen - chain operations

Chain operations that might fail. The function only runs if the previous result was `ok`.

```typescript
import { andThen } from 'awaitly';

const result = ok(10);
const chained = andThen(result, (n) =>
  n > 0 ? ok(n * 2) : err('NEGATIVE')
);
/*
Output:
{ ok: true, value: 20 }
*/

const negative = ok(-5);
const failed = andThen(negative, (n) =>
  n > 0 ? ok(n * 2) : err('NEGATIVE')
);
/*
Output:
{ ok: false, error: 'NEGATIVE' }
*/
```

### match - pattern match

```typescript
import { match } from 'awaitly';

const result = divide(10, 2);
const message = match(
  result,
  (value) => `Success: ${value}`,
  (error) => `Error: ${error}`
);
/*
Output:
"Success: 5"
*/
```

## Unwrapping

### unwrap - get value or throw

<Aside type="caution" title="Use sparingly">
`unwrap` throws if the result is an error. Use it only when you're certain the result is ok, or at application boundaries.
</Aside>

```typescript
import { unwrap } from 'awaitly';

const result = divide(10, 2);
const value = unwrap(result);
/*
Output:
5
*/

const badResult = divide(10, 0);
const boom = unwrap(badResult); // Throws!
```

### unwrapOr - get value or default

```typescript
import { unwrapOr } from 'awaitly';

const result = divide(10, 0);
const value = unwrapOr(result, 0);
/*
Output:
0
*/
```

### unwrapOrElse - get value or compute default

```typescript
import { unwrapOrElse } from 'awaitly';

const result = divide(10, 0);
const value = unwrapOrElse(result, (error) => {
  console.log('Failed with:', error);
  return 0;
});
/*
Output:
Failed with: DIVIDE_BY_ZERO
0
*/
```

## Wrapping throwing code

### from - wrap sync function

```typescript
import { from } from 'awaitly';

const result = from(() => JSON.parse('{"valid": true}'));
/*
Output:
{ ok: true, value: { valid: true } }
*/

const invalid = from(() => JSON.parse('not json'));
/*
Output:
{ ok: false, error: SyntaxError }
*/
```

### fromPromise - wrap async function

```typescript
import { fromPromise } from 'awaitly';

const result = await fromPromise(fetch('/api/data'));
/*
Output (on success):
{ ok: true, value: Response }

Output (on network error):
{ ok: false, error: TypeError }
*/
```

### tryAsync - wrap with custom error

```typescript
import { tryAsync } from 'awaitly';

const result = await tryAsync(
  () => fetch('/api/data').then(r => r.json()),
  (thrown) => ({ type: 'FETCH_FAILED' as const, cause: thrown })
);
/*
Output (on success):
{ ok: true, value: { ...data } }

Output (on failure):
{ ok: false, error: { type: 'FETCH_FAILED', cause: Error } }
*/
```

## Batch operations

### all - fail fast

Returns the first error encountered, or all values if everything succeeds.

```typescript
import { all } from 'awaitly';

const results = [ok(1), ok(2), ok(3)];
const combined = all(results);
/*
Output:
{ ok: true, value: [1, 2, 3] }
*/

const withError = [ok(1), err('FAILED'), ok(3)];
const failed = all(withError);
/*
Output:
{ ok: false, error: 'FAILED' }
*/
```

### allSettled - collect all

Always succeeds, collecting the outcome of each operation.

```typescript
import { allSettled } from 'awaitly';

const results = [ok(1), err('A'), ok(3), err('B')];
const settled = allSettled(results);
/*
Output:
{
  ok: true,
  value: [
    { status: 'ok', value: 1 },
    { status: 'err', error: 'A' },
    { status: 'ok', value: 3 },
    { status: 'err', error: 'B' },
  ]
}
*/
```

### partition - separate successes and failures

```typescript
import { partition } from 'awaitly';

const results = [ok(1), err('A'), ok(3)];
const [successes, failures] = partition(results);
/*
Output:
successes: [1, 3]
failures: ['A']
*/
```

<Aside type="tip" title="When to use each">
- **all**: When any failure should stop everything (transactions, validation)
- **allSettled**: When you want all outcomes regardless of failures
- **partition**: When you need to process successes and failures separately
</Aside>

## Async versions

Most operations have async variants for working with promises:

```typescript
import { allAsync, anyAsync } from 'awaitly';

const results = await allAsync([
  fetchUser('1'),
  fetchPosts('1'),
  fetchComments('1'),
]);
/*
Output (all succeed):
{ ok: true, value: [User, Post[], Comment[]] }

Output (one fails):
{ ok: false, error: 'NOT_FOUND' }
*/
```

## Comparison with other patterns

<Tabs>
  <TabItem label="Result types">
```typescript
const result = divide(10, 2);
if (result.ok) {
  console.log(result.value);
} else {
  console.log(result.error);
}
// TypeScript knows the types at each branch
```
  </TabItem>
  <TabItem label="try/catch">
```typescript
try {
  const value = divide(10, 2);
  console.log(value);
} catch (error) {
  console.log(error);
  // What type is error? TypeScript doesn't know
}
```
  </TabItem>
</Tabs>

## Next

[Learn about Steps →](../step/)
