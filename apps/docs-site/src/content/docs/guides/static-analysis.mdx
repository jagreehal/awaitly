---
title: Static Analysis
description: Analyze workflow structure without execution
---

Analyze workflow source code to extract structure, dependencies, and generate visualization data without executing the workflow.

**Documentation fields:** `description` and `markdown` on workflows and steps are the canonical way to feed static analysis and doc generation. See [Documenting workflows](/docs/guides/documenting-workflows/) for how to set them. JSDoc above workflow and step declarations is also extracted and available as `jsdocDescription` on the root and step nodes.

**Step names:** `step()` requires a string literal as the first argument. The analyzer uses that string as the step **display name** (for docs/diagrams). There is no inference; a missing or non-string first argument is reported as an error. See [Steps](/docs/foundations/step/#basic-usage) for usage.

## CLI Tool

The `awaitly-analyze` CLI analyzes TypeScript workflow files and outputs Mermaid diagrams or JSON:

```bash
# Output Mermaid diagram (default)
npx awaitly-analyze ./src/workflows/checkout.ts

# Output JSON
npx awaitly-analyze ./src/workflows/checkout.ts --format=json

# Pipe to file
npx awaitly-analyze ./src/workflows/checkout.ts > workflow.md

# Show step cache keys
npx awaitly-analyze ./src/workflows/checkout.ts --keys

# Change diagram direction (TB, LR, BT, RL)
npx awaitly-analyze ./src/workflows/checkout.ts --direction=LR
```

### Interactive HTML

Generate a self-contained HTML file with an interactive Mermaid diagram, click-to-inspect node details, and a built-in theme picker:

```bash
# Generate interactive HTML (writes <basename>.html next to source)
npx awaitly-analyze ./src/workflows/checkout.ts --html

# Custom output path
npx awaitly-analyze ./src/workflows/checkout.ts --html --html-output=./docs/checkout-diagram.html
```

The generated HTML file is fully self-contained — it loads Mermaid from a CDN and embeds all workflow metadata inline. Open it in any browser; no dev server needed.

**What's included:**

- **Mermaid diagram** rendered client-side via CDN
- **Click-to-inspect** — click any node to see its step ID, callee, retry/timeout config, types, data flow, and source location in a side panel
- **6 color themes** — 4 dark (Midnight, Ocean, Ember, Forest) and 2 light (Daylight, Paper)
- **System preference detection** — auto-selects a dark or light theme based on `prefers-color-scheme`
- **localStorage persistence** — your theme choice is remembered across sessions

**Programmatic usage:**

```typescript
import {
  analyze,
  renderStaticMermaid,
  extractNodeMetadata,
  generateInteractiveHTML,
} from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();
const mermaid = renderStaticMermaid(ir);
const metadata = extractNodeMetadata(ir);
const html = generateInteractiveHTML(mermaid, metadata, {
  theme: 'midnight',    // optional: force a specific theme
  title: 'Checkout',    // optional: override page title
  direction: 'TB',      // optional: diagram direction
});

// Write to disk
import { writeFileSync } from 'node:fs';
writeFileSync('checkout.html', html);
```

See [Renderers → Interactive HTML renderer](#interactive-html-renderer) for the full API.

### Multi-workflow output

When a file contains multiple workflows, each gets its own section with a markdown header and mermaid diagram:

```text
## Workflow: checkoutWorkflow

(mermaid diagram for checkout workflow)

## Workflow: paymentWorkflow

(mermaid diagram for payment workflow)
```

## Basic usage

```typescript
import { analyze } from 'awaitly-analyze';

// Analyze a single-workflow file
const ir = analyze('./src/workflows/checkout.ts').single();
console.log(`Steps: ${ir.metadata.stats.totalSteps}`);

// Analyze a multi-workflow file
const workflows = analyze('./src/workflows/all.ts').all();
for (const ir of workflows) {
  console.log(`${ir.root.workflowName}: ${ir.metadata.stats.totalSteps} steps`);
}

// Get a specific workflow by name
const checkout = analyze('./src/workflows/all.ts').named('checkoutWorkflow');
```

### Fluent API methods

| Method | Returns | Throws | Use when |
|--------|---------|--------|----------|
| `.single()` | Single IR | If 0 or >1 workflows | File has exactly one workflow |
| `.singleOrNull()` | IR or null | Never | Checking if file has one workflow |
| `.all()` | IR array | Never | Processing all workflows in file |
| `.named(name)` | Single IR | If not found | Targeting specific workflow by name |
| `.first()` | Single IR | If empty | Getting first workflow, don't care about count |
| `.firstOrNull()` | IR or null | Never | Safely getting first workflow |

**Choosing the right method:**

```typescript
// Most common: single workflow per file
const ir = analyze('./checkout.ts').single();

// Multi-workflow files: iterate all
for (const ir of analyze('./workflows.ts').all()) {
  console.log(ir.root.workflowName);
}

// Target by name when you know what you want
const payment = analyze('./workflows.ts').named('paymentWorkflow');

// Safe access when file might be empty
const ir = analyze(filePath).firstOrNull();
if (ir) {
  // process workflow
}
```

## Analyzing source strings

Analyze workflow code directly without reading from a file:

```typescript
import { analyze } from 'awaitly-analyze';

const source = `
  const checkout = createWorkflow('workflow', deps);

  async function run() {
    return await checkout.run(async ({ step, deps }) => {
      const cart = await step('fetchCart', () => deps.fetchCart(), { key: 'cart' });
      const total = await step('calculateTotal', () => deps.calculateTotal(cart), { key: 'total' });
      return { cart, total };
    });
  }
`;

const ir = analyze.source(source).single();
console.log(ir.metadata.stats);
// { totalSteps: 2, conditionalCount: 0, parallelCount: 0, ... }
```

## What gets detected

The analyzer extracts:

| Feature | Detection |
|---------|-----------|
| Steps | `step()`, `step.retry()`, `step.withTimeout()` |
| Conditionals | `if/else`, `when()`, `unless()`, `whenOr()`, `unlessOr()` |
| Loops | `for`, `while`, `for-of`, `for-in` |
| Parallel | `step.parallel()`, `allAsync()`, `allSettledAsync()` |
| Race | `step.race()`, `anyAsync()` |
| Retry/Timeout | Options in step config, `step.retry()`, `step.withTimeout()` |
| Workflow refs | Calls to other workflows |

### Supported callback patterns

The analyzer handles various callback patterns:

```typescript
// Simple identifier
workflow.run(async ({ step, deps }) => { ... });

// Destructuring
workflow.run(async ({ step }) => { ... });

// Destructuring with alias
workflow.run(async ({ step: runStep }) => { ... });

// Destructuring with default
workflow.run(async ({ step = defaultStep }) => { ... });

// Destructuring with alias and default
workflow.run(async ({ step: runStep = fallback }) => { ... });
```

## IR structure

The analyzer returns a `StaticWorkflowIR` with:

```typescript
interface StaticWorkflowIR {
  root: StaticWorkflowNode;      // Workflow tree
  metadata: StaticAnalysisMetadata;
  references: Map<string, StaticWorkflowIR>;
}

interface StaticAnalysisMetadata {
  analyzedAt: number;
  filePath: string;
  warnings: AnalysisWarning[];
  stats: AnalysisStats;
}

interface AnalysisStats {
  totalSteps: number;
  conditionalCount: number;
  parallelCount: number;
  raceCount: number;
  loopCount: number;
  workflowRefCount: number;
  unknownCount: number;
}
```

## Node types

The workflow tree contains these node types:

```typescript
type StaticFlowNode =
  | StaticStepNode        // step() call
  | StaticSequenceNode    // Sequential steps
  | StaticParallelNode    // Parallel execution
  | StaticRaceNode        // Race execution
  | StaticConditionalNode // if/else or conditional helpers
  | StaticLoopNode        // for/while loops
  | StaticWorkflowRefNode // Call to another workflow
  | StaticUnknownNode;    // Unanalyzable code
```

## API types reference

Main static-analysis node types and when fields are populated:

- **StaticWorkflowNode** (root): `workflowName`, `source`, `dependencies`, `children`, `description`, `markdown`, `jsdocDescription?`, `errorTypes`.
  `description` and `markdown` are set only for `createWorkflow` / `createSagaWorkflow` (from options or deps). They are undefined for `run()` / `runSaga()`. `jsdocDescription` is extracted from JSDoc above the workflow variable when present.

- **StaticStepNode**: `stepId`, `callee`, `name`, `key`, `description`, `markdown`, `jsdocDescription?`, `retry`, `timeout`, `errors?`, `out?`, `reads?`.
  `stepId` is required and comes from the first argument to **`step('id', fn, opts)`**. `description` and `markdown` come from step options. `jsdocDescription` is extracted from JSDoc above the step statement.

- **StaticSagaStepNode**: `callee`, `name`, `description`, `markdown`, `jsdocDescription?`, `hasCompensation`, `compensationCallee`, `isTryStep`.
  `description` and `markdown` come from saga step options.

- **DependencyInfo**: `name`, `typeSignature?`, `errorTypes`.
  `typeSignature` is the TypeScript type when the type checker is available. `errorTypes` is not yet inferred from types.

## Walking the tree

Use the built-in helpers to traverse nodes:

```typescript
import {
  analyze,
  isStaticStepNode,
  isStaticConditionalNode,
  getStaticChildren
} from 'awaitly-analyze';

function walkWorkflow(node: StaticFlowNode) {
  if (isStaticStepNode(node)) {
    console.log(`Step: ${node.key || node.name}`);
  }

  if (isStaticConditionalNode(node)) {
    console.log(`Condition: ${node.condition}`);
  }

  // Recursively walk children
  for (const child of getStaticChildren(node)) {
    walkWorkflow(child);
  }
}

const ir = analyze('./checkout.ts').single();
for (const child of ir.root.children) {
  walkWorkflow(child);
}
```

## Multiple workflows

A single file can contain multiple workflows:

```typescript
import { analyze } from 'awaitly-analyze';

const source = `
  const workflowA = createWorkflow('workflowA', depsA);
  const workflowB = createWorkflow('workflowB', depsB);

  async function runA() {
    return await workflowA.run(async ({ step }) => { ... });
  }

  async function runB() {
    return await workflowB.run(async ({ step }) => { ... });
  }
`;

const result = analyze.source(source);

// Get all workflows
const workflows = result.all();
console.log(workflows.length); // 2

// Get by name
const wfA = analyze.source(source).named('workflowA');
const wfB = analyze.source(source).named('workflowB');
```

## Use cases

### Generating documentation

Use `description` and `markdown` on workflows and steps (see [Documenting workflows](/docs/guides/documenting-workflows/)) so the analyzer can extract them. Then:

1. Call `analyze(filePath).all()` to get all workflows in a file.
2. For each IR: use `root.workflowName`, `root.description`, `root.markdown` for the workflow title and body.
3. Walk `root.children` (and nested sequences) to list steps; use each step’s `name`, `key`, `description`, `markdown` for step tables or lists.
4. Optionally use `generatePaths(ir)` and `renderStaticMermaid(ir)` for path coverage and diagrams.

Minimal recipe:

```typescript
import { analyze, getStaticChildren, isStaticStepNode } from 'awaitly-analyze';

const workflows = analyze('./src/workflows/checkout.ts').all();

for (const ir of workflows) {
  const { root } = ir;
  console.log(`# ${root.workflowName}\n`);
  if (root.description) console.log(root.description + '\n');
  if (root.markdown) console.log(root.markdown + '\n');
  console.log(`- ${ir.metadata.stats.totalSteps} steps\n`);

  function listSteps(node) {
    if (isStaticStepNode(node)) {
      const name = node.stepId;
      console.log(`- **${name}**${node.description ? ` — ${node.description}` : ''}`);
    }
    for (const child of getStaticChildren(node)) listSteps(child);
  }
  for (const child of root.children) listSteps(child);
}
```

An optional script that does this is provided in the repo: run `node packages/awaitly-analyze/scripts/generate-workflow-docs.mjs <path-to-workflow.ts>` from the repo root (after building awaitly-analyze) to output one markdown section per workflow.

### Build test coverage matrix

```typescript
import { analyze, isStaticConditionalNode } from 'awaitly-analyze';

function countPaths(node: StaticFlowNode): number {
  if (isStaticConditionalNode(node)) {
    const thenPaths = node.consequent.reduce((n, c) => n * countPaths(c), 1);
    const elsePaths = (node.alternate || []).reduce((n, c) => n * countPaths(c), 1);
    return thenPaths + elsePaths;
  }
  // ... handle other node types
  return 1;
}

const ir = analyze('./checkout.ts').single();
console.log(`Execution paths: ${countPaths(ir.root)}`);
```

### Validate workflow complexity

```typescript
import { analyze } from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();
const stats = ir.metadata.stats;

if (stats.totalSteps > 20) {
  console.warn('Consider breaking this workflow into smaller pieces');
}

if (stats.conditionalCount > 5) {
  console.warn('High cyclomatic complexity');
}
```

## Renderers

Generate output from the IR using built-in renderers:

### Mermaid renderer

```typescript
import { analyze, renderStaticMermaid } from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();
const mermaid = renderStaticMermaid(ir, {
  direction: 'TB',      // TB, LR, BT, RL
  showKeys: false,      // Show step cache keys
  showConditions: true, // Show condition text
});

console.log(mermaid);
// flowchart TB
//   start(("▶"))
//   step_1["Fetch cart"]
//   ...
```

### JSON renderer

```typescript
import { analyze, renderStaticJSON, renderMultipleStaticJSON } from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();
const json = renderStaticJSON(ir, { pretty: true });

// For multiple workflows
const workflows = analyze('./checkout.ts').all();
const multiJson = renderMultipleStaticJSON(workflows, './checkout.ts', {
  pretty: true,
});
```

### JSON output shape

The output of `renderStaticJSON(ir)` has this structure:

- **Top level**: `{ root, metadata?, references? }`
- **StaticWorkflowNode**: `type: "workflow"`, `id`, `workflowName`, `source?`, `dependencies[]`, `errorTypes[]`, `children[]`, `description?`, `markdown?`, `jsdocDescription?`
- **Flow nodes** (discriminated by `type`): `"step"` (includes required `stepId` from the first argument), `"saga-step"`, `"sequence"`, `"parallel"`, `"race"`, `"conditional"`, `"switch"`, `"loop"`, `"stream"`, `"workflow-ref"`, `"unknown"`

A JSON Schema for validation is available at `schema/static-workflow-ir.schema.json` in the awaitly-analyze package.

### Interactive HTML renderer

Generate a self-contained HTML file with an interactive Mermaid diagram and click-to-inspect panel. This is the same output produced by the `--html` CLI flag.

The pipeline has two steps: extract metadata from the IR, then combine it with the Mermaid text into HTML:

```typescript
import {
  analyze,
  renderStaticMermaid,
  extractNodeMetadata,
  generateInteractiveHTML,
} from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();
const mermaid = renderStaticMermaid(ir);
const metadata = extractNodeMetadata(ir);
const html = generateInteractiveHTML(mermaid, metadata, { theme: 'midnight' });
```

**`extractNodeMetadata(ir)`** walks the IR tree and returns a `WorkflowMetadata` object containing per-node metadata (step IDs, callees, retry/timeout config, types, source locations) keyed by the Mermaid node ID so the HTML click handler can look up details.

**`generateInteractiveHTML(mermaidText, metadata, options?)`** returns a complete HTML string. Options:

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `title` | `string` | workflow name | Page title |
| `theme` | `string` | auto-detect | Initial theme (`midnight`, `ocean`, `ember`, `forest`, `daylight`, `paper`) |
| `mermaidCdnUrl` | `string` | latest v11 | Mermaid CDN URL |
| `direction` | `string` | `TB` | Diagram direction |

### Custom names

Parallel and race nodes support custom names that appear in diagrams:

```typescript
// Object form with name option
await step.parallel('Fetch user data', {
  user: () => deps.fetchUser(),
  posts: () => deps.fetchPosts(),
});

// Array form with name
await step.parallel('Fetch all', () => allAsync([
  deps.fetchUser(),
  deps.fetchPosts(),
]));
```

Both forms render with the custom name in Mermaid diagrams instead of generic "Parallel (all)".

## Limitations

- **Dynamic code**: Template literals in step keys show as `<dynamic>`
- **External imports**: Referenced workflows must be in the same file to resolve

## Next

[Learn about Visualization →](/visualization/)
