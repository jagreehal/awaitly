---
title: Static Analysis
description: Analyze workflow structure without execution
---

Analyze workflow source code to extract structure, dependencies, and generate visualization data without executing the workflow.

## CLI Tool

The `awaitly-analyze` CLI analyzes TypeScript workflow files and outputs Mermaid diagrams or JSON:

```bash
# Output Mermaid diagram (default)
npx awaitly-analyze ./src/workflows/checkout.ts

# Output JSON
npx awaitly-analyze ./src/workflows/checkout.ts --format=json

# Pipe to file
npx awaitly-analyze ./src/workflows/checkout.ts > workflow.md

# Show step cache keys
npx awaitly-analyze ./src/workflows/checkout.ts --keys

# Change diagram direction (TB, LR, BT, RL)
npx awaitly-analyze ./src/workflows/checkout.ts --direction=LR
```

### Multi-workflow output

When a file contains multiple workflows, each gets its own section with a markdown header and mermaid diagram:

```text
## Workflow: checkoutWorkflow

(mermaid diagram for checkout workflow)

## Workflow: paymentWorkflow

(mermaid diagram for payment workflow)
```

## Basic usage

```typescript
import { analyze } from 'awaitly-analyze';

// Analyze a single-workflow file
const ir = analyze('./src/workflows/checkout.ts').single();
console.log(`Steps: ${ir.metadata.stats.totalSteps}`);

// Analyze a multi-workflow file
const workflows = analyze('./src/workflows/all.ts').all();
for (const ir of workflows) {
  console.log(`${ir.root.workflowName}: ${ir.metadata.stats.totalSteps} steps`);
}

// Get a specific workflow by name
const checkout = analyze('./src/workflows/all.ts').named('checkoutWorkflow');
```

### Fluent API methods

| Method | Returns | Throws | Use when |
|--------|---------|--------|----------|
| `.single()` | Single IR | If 0 or >1 workflows | File has exactly one workflow |
| `.singleOrNull()` | IR or null | Never | Checking if file has one workflow |
| `.all()` | IR array | Never | Processing all workflows in file |
| `.named(name)` | Single IR | If not found | Targeting specific workflow by name |
| `.first()` | Single IR | If empty | Getting first workflow, don't care about count |
| `.firstOrNull()` | IR or null | Never | Safely getting first workflow |

**Choosing the right method:**

```typescript
// Most common: single workflow per file
const ir = analyze('./checkout.ts').single();

// Multi-workflow files: iterate all
for (const ir of analyze('./workflows.ts').all()) {
  console.log(ir.root.workflowName);
}

// Target by name when you know what you want
const payment = analyze('./workflows.ts').named('paymentWorkflow');

// Safe access when file might be empty
const ir = analyze(filePath).firstOrNull();
if (ir) {
  // process workflow
}
```

## Analyzing source strings

Analyze workflow code directly without reading from a file:

```typescript
import { analyze } from 'awaitly-analyze';

const source = `
  const checkout = createWorkflow(deps);

  async function run() {
    return await checkout(async (step, deps) => {
      const cart = await step(() => deps.fetchCart(), { key: 'cart' });
      const total = await step(() => deps.calculateTotal(cart), { key: 'total' });
      return { cart, total };
    });
  }
`;

const ir = analyze.source(source).single();
console.log(ir.metadata.stats);
// { totalSteps: 2, conditionalCount: 0, parallelCount: 0, ... }
```

## What gets detected

The analyzer extracts:

| Feature | Detection |
|---------|-----------|
| Steps | `step()`, `step.retry()`, `step.withTimeout()` |
| Conditionals | `if/else`, `when()`, `unless()`, `whenOr()`, `unlessOr()` |
| Loops | `for`, `while`, `for-of`, `for-in` |
| Parallel | `step.parallel()`, `allAsync()`, `allSettledAsync()` |
| Race | `step.race()`, `anyAsync()` |
| Retry/Timeout | Options in step config, `step.retry()`, `step.withTimeout()` |
| Workflow refs | Calls to other workflows |

### Supported callback patterns

The analyzer handles various callback patterns:

```typescript
// Simple identifier
workflow(async (step, deps) => { ... });

// Destructuring
workflow(async ({ step }, deps) => { ... });

// Destructuring with alias
workflow(async ({ step: runStep }, deps) => { ... });

// Destructuring with default
workflow(async ({ step = defaultStep }, deps) => { ... });

// Destructuring with alias and default
workflow(async ({ step: runStep = fallback }, deps) => { ... });
```

## IR structure

The analyzer returns a `StaticWorkflowIR` with:

```typescript
interface StaticWorkflowIR {
  root: StaticWorkflowNode;      // Workflow tree
  metadata: StaticAnalysisMetadata;
  references: Map<string, StaticWorkflowIR>;
}

interface StaticAnalysisMetadata {
  analyzedAt: number;
  filePath: string;
  warnings: AnalysisWarning[];
  stats: AnalysisStats;
}

interface AnalysisStats {
  totalSteps: number;
  conditionalCount: number;
  parallelCount: number;
  raceCount: number;
  loopCount: number;
  workflowRefCount: number;
  unknownCount: number;
}
```

## Node types

The workflow tree contains these node types:

```typescript
type StaticFlowNode =
  | StaticStepNode        // step() call
  | StaticSequenceNode    // Sequential steps
  | StaticParallelNode    // Parallel execution
  | StaticRaceNode        // Race execution
  | StaticConditionalNode // if/else or conditional helpers
  | StaticLoopNode        // for/while loops
  | StaticWorkflowRefNode // Call to another workflow
  | StaticUnknownNode;    // Unanalyzable code
```

## Walking the tree

Use the built-in helpers to traverse nodes:

```typescript
import {
  analyze,
  isStaticStepNode,
  isStaticConditionalNode,
  getStaticChildren
} from 'awaitly-analyze';

function walkWorkflow(node: StaticFlowNode) {
  if (isStaticStepNode(node)) {
    console.log(`Step: ${node.key || node.name}`);
  }

  if (isStaticConditionalNode(node)) {
    console.log(`Condition: ${node.condition}`);
  }

  // Recursively walk children
  for (const child of getStaticChildren(node)) {
    walkWorkflow(child);
  }
}

const ir = analyze('./checkout.ts').single();
for (const child of ir.root.children) {
  walkWorkflow(child);
}
```

## Multiple workflows

A single file can contain multiple workflows:

```typescript
import { analyze } from 'awaitly-analyze';

const source = `
  const workflowA = createWorkflow(depsA);
  const workflowB = createWorkflow(depsB);

  async function runA() {
    return await workflowA(async (step) => { ... });
  }

  async function runB() {
    return await workflowB(async (step) => { ... });
  }
`;

const result = analyze.source(source);

// Get all workflows
const workflows = result.all();
console.log(workflows.length); // 2

// Get by name
const wfA = analyze.source(source).named('workflowA');
const wfB = analyze.source(source).named('workflowB');
```

## Use cases

### Generate documentation

```typescript
import { analyze } from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();

console.log(`# ${ir.root.workflowName}\n`);
console.log(`- ${ir.metadata.stats.totalSteps} steps`);
console.log(`- ${ir.metadata.stats.conditionalCount} decision points`);
console.log(`- ${ir.metadata.stats.parallelCount} parallel operations`);
```

### Build test coverage matrix

```typescript
import { analyze, isStaticConditionalNode } from 'awaitly-analyze';

function countPaths(node: StaticFlowNode): number {
  if (isStaticConditionalNode(node)) {
    const thenPaths = node.consequent.reduce((n, c) => n * countPaths(c), 1);
    const elsePaths = (node.alternate || []).reduce((n, c) => n * countPaths(c), 1);
    return thenPaths + elsePaths;
  }
  // ... handle other node types
  return 1;
}

const ir = analyze('./checkout.ts').single();
console.log(`Execution paths: ${countPaths(ir.root)}`);
```

### Validate workflow complexity

```typescript
import { analyze } from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();
const stats = ir.metadata.stats;

if (stats.totalSteps > 20) {
  console.warn('Consider breaking this workflow into smaller pieces');
}

if (stats.conditionalCount > 5) {
  console.warn('High cyclomatic complexity');
}
```

## Renderers

Generate output from the IR using built-in renderers:

### Mermaid renderer

```typescript
import { analyze, renderStaticMermaid } from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();
const mermaid = renderStaticMermaid(ir, {
  direction: 'TB',      // TB, LR, BT, RL
  showKeys: false,      // Show step cache keys
  showConditions: true, // Show condition text
});

console.log(mermaid);
// flowchart TB
//   start(("▶"))
//   step_1["Fetch cart"]
//   ...
```

### JSON renderer

```typescript
import { analyze, renderStaticJSON, renderMultipleStaticJSON } from 'awaitly-analyze';

const ir = analyze('./checkout.ts').single();
const json = renderStaticJSON(ir, { pretty: true });

// For multiple workflows
const workflows = analyze('./checkout.ts').all();
const multiJson = renderMultipleStaticJSON(workflows, './checkout.ts', {
  pretty: true,
});
```

### Custom names

Parallel and race nodes support custom names that appear in diagrams:

```typescript
// Object form with name option
await step.parallel(
  { user: () => deps.fetchUser(), posts: () => deps.fetchPosts() },
  { name: 'Fetch user data' }
);

// Array form with name
await step.parallel('Fetch all', () => allAsync([
  deps.fetchUser(),
  deps.fetchPosts(),
]));
```

Both forms render with the custom name in Mermaid diagrams instead of generic "Parallel (all)".

## Limitations

- **Dynamic code**: Template literals in step keys show as `<dynamic>`
- **External imports**: Referenced workflows must be in the same file to resolve

## Next

[Learn about Visualization →](/visualization/)
