---
title: Steps
description: The step() function and its variants
---

import { Aside } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';

`step()` executes an operation within a workflow. If the operation fails, the workflow exits early.

## Basic usage

`step()` requires an explicit string ID as the first argument: `step('id', fn, opts)` or `step('id', result, opts)`. The string literal is the step ID used in events, diagrams, and caching.

```typescript
const workflow = createWorkflow({ fetchUser, fetchPosts });

const result = await workflow(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'));
  const posts = await step('fetchPosts', () => fetchPosts(user.id));
  return { user, posts };
});
```

<Aside type="tip" title="Early exit">
Unlike try/catch where you need explicit return statements, `step()` automatically exits the workflow on error. The error becomes the workflow's result.
</Aside>

## Using thunks for caching

Pass a function (thunk) as the second argument so the step can be cached. The first argument is the required string ID:

```typescript
const user = await step('fetchUser', () => fetchUser('1'), { key: 'user:1' });
```

<Aside type="note">
A thunk is just a function with no arguments that returns the value. Using thunks lets awaitly control when (and whether) to execute the operation.
</Aside>

## Step options

Pass options as the third argument to `step('id', fn, opts)`:

```typescript
const user = await step('fetchUser', () => fetchUser('1'), {
  key: 'user:1',            // For caching/deduplication
  retry: { attempts: 3 },   // Retry on failure
  timeout: { ms: 5000 },    // Timeout after 5 seconds
  description: 'Load user by ID',  // For generated docs
});
```

## Step ID and key: label vs instance

The **first argument** is the step **label** (what kind of step: `'fetchUser'`, `'sendEmail'`). It must be a string literal and is used in diagrams, events, and static docs.

The **`key`** option (optional) is the **instance** identity (which iteration or entity: `user:${id}`, `payment-${payment.id}`). When present, the runtime uses it for cache, snapshots, and events—so per-iteration identity comes from `key`, not from the first argument.

In loops, use one literal step ID (label) and a per-iteration `key` (instance) so events and snapshots still get distinct identities per iteration.

## step.try - wrap throwing code

Convert exceptions into typed errors:

```typescript
const data = await step.try(
  'fetchData',
  async () => {
    const res = await fetch('/api/data');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  },
  { error: 'FETCH_FAILED' as const }
);
/*
Output (success):
data contains the parsed JSON

Output (failure):
Workflow returns { ok: false, error: 'FETCH_FAILED' }
*/
```

<Aside type="tip" title="Error type safety">
The `as const` assertion is important. It tells TypeScript this is the literal string `'FETCH_FAILED'`, not just `string`.
</Aside>

The error type is added to the workflow's error union automatically.

## step.fromResult - preserve error details

When your operation returns a Result with rich error objects:

```typescript
type ApiError = { code: number; message: string };

const callApi = async (): AsyncResult<Data, ApiError> => {
  // Returns err({ code: 429, message: 'Rate limited' })
};

const data = await step.fromResult(
  'callApi',
  () => callApi(),
  {
    onError: (apiError) => ({
      type: 'API_ERROR' as const,
      ...apiError,
    }),
  }
);
/*
Output (on rate limit):
{ ok: false, error: { type: 'API_ERROR', code: 429, message: 'Rate limited' } }
*/
```

## step.retry - retry with backoff

`step.retry` requires an ID as the first argument: `step.retry(id, operation, options)`. Use optional `key` for per-iteration identity (e.g. in loops).

```typescript
const user = await step.retry(
  'fetchUser',
  () => fetchUser('1'),
  {
    attempts: 3,
    backoff: 'exponential',  // 'fixed' | 'linear' | 'exponential'
    delayMs: 100,            // Base delay
    maxDelayMs: 5000,        // Cap for exponential
    jitter: true,            // Add randomness
    retryOn: (error) => error !== 'NOT_FOUND', // Don't retry NOT_FOUND
  }
);
```

### Backoff strategies visualized

```text
Fixed (delayMs: 100):
#1: 100ms   ████
#2: 100ms   ████
#3: 100ms   ████

Linear (delayMs: 100):
#1: 100ms   ████
#2: 200ms   ████████
#3: 300ms   ████████████

Exponential (delayMs: 100):
#1: 100ms   ████
#2: 200ms   ████████
#3: 400ms   ████████████████
#4: 800ms   ████████████████████████████████
```

<Aside type="note">
Exponential backoff is recommended for network calls. It reduces load on struggling services while still retrying failed operations.
</Aside>

## step.withTimeout - add timeout

`step.withTimeout` requires an ID as the first argument: `step.withTimeout(id, operation, options)`. Use optional `key` for per-iteration identity (e.g. in loops).

```typescript
const data = await step.withTimeout(
  'slowOp',
  () => slowOperation(),
  { ms: 5000 }
);
/*
Output (completes in time):
data contains the result

Output (times out):
{ ok: false, error: StepTimeoutError }
*/
```

If the timeout is reached, the workflow gets a `StepTimeoutError`.

## Combining retry and timeout

```typescript
const data = await step.retry(
  'fetchData',
  () => step.withTimeout('fetchData', () => fetchData(), { ms: 2000 }),
  { attempts: 3, backoff: 'exponential' }
);
```

Each attempt has a 2-second timeout. The whole operation retries up to 3 times.

```text
Timeline:
├── Attempt 1 ──────────────► timeout at 2s
│   wait 100ms
├── Attempt 2 ──────────────► timeout at 2s
│   wait 200ms
├── Attempt 3 ──────────────► timeout at 2s (or success!)
```

## step.sleep - pause execution

Pause execution for a specified duration. Use for intentional delays between operations (rate limiting, polling intervals, debouncing). Respects workflow cancellation.

`step.sleep` requires an ID as the first argument: `step.sleep(id, duration, options?)`. Use optional `key` for per-iteration identity (e.g. in loops).

### Basic usage

```typescript
// String duration
await step.sleep("rate-limit-delay", "5s");

// Duration object
import { seconds, millis } from 'awaitly/workflow';
await step.sleep("my-sleep", seconds(5));
await step.sleep("short-delay", millis(100));
```

### With options

```typescript
await step.sleep("poll-delay", "2s", {
  key: "poll-delay",          // For caching/deduplication (optional)
  ttl: 5000,                   // Cache TTL in milliseconds
  description: "Wait before next poll attempt",
  signal: controller.signal    // Optional AbortSignal for cancellation
});
```

### Rate limiting example

```typescript
const result = await workflow(async (step) => {
  const data = await step('fetchData', () => fetchData());
  
  // Respect rate limits - wait 1 second between requests
  await step.sleep("rate-limit-delay", "1s");
  
  const moreData = await step('fetchMoreData', () => fetchMoreData());
  return { data, moreData };
});
```

### Polling example

```typescript
const result = await workflow(async (step) => {
  let status = await step('checkStatus', () => checkStatus());
  
  // Poll every 2 seconds until complete
  while (status !== "complete") {
    await step.sleep("poll-interval", "2s");
    status = await step('checkStatus', () => checkStatus());
  }
  
  return status;
});
```

### Cancellation

`step.sleep` supports two cancellation mechanisms:

**Workflow cancellation** - Cancel the entire workflow:

```typescript
const controller = new AbortController();
const workflow = createWorkflow({}, { signal: controller.signal });

const resultPromise = workflow(async (step) => {
  await step.sleep("long-sleep", "10s");
  return "completed";
});

// Cancel after 1 second
setTimeout(() => controller.abort(), 1000);

const result = await resultPromise;
// result.ok is false, error is WorkflowCancelledError
```

**User-provided signal** - Cancel a specific sleep without affecting the workflow:

```typescript
const result = await run(async (step) => {
  const sleepController = new AbortController();

  // Cancel this specific sleep after 1 second
  setTimeout(() => sleepController.abort(), 1000);

  try {
    await step.sleep("long-sleep", "10s", {
      signal: sleepController.signal
    });
    return "completed normally";
  } catch {
    // Sleep was cancelled by user signal
    return "sleep cancelled, continuing workflow";
  }
});
```

<Aside type="tip" title="Duration formats">
You can use string durations like `"5s"`, `"100ms"`, `"2m"`, or Duration objects from `awaitly/workflow` like `seconds(5)`, `millis(100)`.
</Aside>

## step.forEach - process collections

Process arrays with automatic indexing, resume support, and static analyzability:

```typescript
await step.forEach('process-payments', payments, {
  stepIdPattern: 'payment-{i}',
  run: async (payment) => {
    const result = await step('processPayment', () => processPayment(payment));
    return result;
  }
});
```

### Basic usage

```typescript
// Process items with automatic indexing
await step.forEach('send-emails', users, {
  stepIdPattern: 'email-{i}',
  run: async (user) => {
    await step('sendEmail', () => sendEmail(user.email));
  }
});
```

### Collecting results

```typescript
// Collect all results into an array
const results = await step.forEach('fetch-users', userIds, {
  stepIdPattern: 'user-{i}',
  collect: 'array',  // or 'last' for only the final result
  run: async (userId) => {
    return await step('fetchUser', () => fetchUser(userId));
  }
});
// results is User[]
```

### Why step.forEach over manual loops?

When you use a manual `for` loop, use **one literal step ID** (label) and a **per-iteration `key`** (instance). Prefer `step.forEach()` when you need full static analyzability.

```typescript
// Option A: manual loop — one literal ID + key per iteration
for (const payment of payments) {
  await step('processPayment', () => processPayment(payment), { key: `payment-${payment.id}` });
}

// Preferred when static analysis matters: step.forEach() is enumerable
await step.forEach('process-payments', payments, {
  stepIdPattern: 'payment-{i}',
  run: (payment) => step('processPayment', () => processPayment(payment))
});
```

Manual `for` loops with dynamic keys like `${item.id}`:
- Cannot be enumerated by static analysis tools
- Reduce path generation accuracy for [awaitly-analyze](/guides/static-analysis/)
- Make test matrix generation incomplete

<Aside type="tip" title="Static analysis support">
`step.forEach()` enables [awaitly-analyze](/guides/static-analysis/) to enumerate all possible execution paths, generate accurate workflow diagrams, and create comprehensive test matrices.
</Aside>

## Parallel steps

Run multiple steps concurrently:

<Tabs>
  <TabItem label="All or nothing">
```typescript
import { allAsync } from 'awaitly';

const result = await workflow(async (step) => {
  const [user, posts, comments] = await step('fetchUserData', () =>
    allAsync([
      fetchUser('1'),
      fetchPosts('1'),
      fetchComments('1'),
    ])
  );
  return { user, posts, comments };
});
/*
Output (all succeed):
{ ok: true, value: { user, posts, comments } }

Output (any fails):
{ ok: false, error: <first error> }
*/
```
  </TabItem>
  <TabItem label="Partial success">
```typescript
import { allSettled } from 'awaitly';

const result = await workflow(async (step) => {
  const results = await step('fetchAllSettled', () =>
    Promise.all([
      fetchUser('1'),
      fetchPosts('1'),
      fetchComments('1'),
    ]).then(allSettled)
  );
  // results contains all outcomes, even failures
  return results;
});
```
  </TabItem>
</Tabs>

## Named steps for visualization and static docs

The required string ID (first argument) is what appears in workflow diagrams and in **statically generated documentation**. [awaitly-analyze](/docs/guides/static-analysis/) extracts it and uses it in Mermaid diagrams, step tables, and doc generators. You can set `description` or `markdown` in options for richer docs. See [Documenting workflows](/docs/guides/documenting-workflows/) and [Visualization](/docs/guides/visualization/) for details.

```typescript
const user = await step('fetchUser', () => fetchUser('1'));
const posts = await step('fetchPosts', () => fetchPosts(user.id));
/*
Workflow diagram and generated docs show:
┌─────────────┐     ┌─────────────┐
│ fetchUser   │ ──► │ fetchPosts  │
└─────────────┘     └─────────────┘
*/
```

## Step variants at a glance

| Variant | Use when |
|---------|----------|
| `step('id', fn)` | Operation returns a Result |
| `step.try(id, fn, opts)` | Operation throws exceptions |
| `step.fromResult(id, fn, opts)` | Need to transform Result errors |
| `step.retry(id, fn, opts)` | Operation might fail transiently |
| `step.withTimeout(id, fn, opts)` | Operation might hang |
| `step.sleep(id, duration, opts)` | Need intentional delay (rate limiting, polling) |
| `step.forEach(id, items, opts)` | Processing collections with static analyzability |

## Next

[Learn about Workflows →](/foundations/workflows/)
