---
title: Steps
description: The step() function and its variants
---

import { Aside } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';

`step()` executes an operation within a workflow. If the operation fails, the workflow exits early.

## Basic usage

You can call `step` in two ways. The **recommended form** is `step('id', fn, opts)` — a string literal step ID as the first argument:

```typescript
const workflow = createWorkflow({ fetchUser, fetchPosts });

const result = await workflow(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'));
  const posts = await step('fetchPosts', () => fetchPosts(user.id));
  return { user, posts };
});
```

The legacy form `step(fn)` or `step(fn, opts)` also works. Awaitly uses the **same resolution order** at runtime and in static analysis. How the step id is determined:

```mermaid
flowchart TD
  subgraph resolve [How step ID is determined]
    A["step(...) called"]
    A --> B{First arg a string?}
    B -->|Yes| C["id = that string"]
    B -->|No| D{First arg a function?}
    D -->|Yes: step(fn, opts)| G["Infer from thunk"]
    G --> H{Match callee in fn.toString()?}
    H -->|Yes| I["id = inferred name"]
    H -->|No| J["id = step_1, step_2, ..."]
    D -->|No: step(result, opts)| K["id = 'directStep'"]
  end
```

Same order as the analyzer: **key is not used for the step id** (key is for caching only).

1. **Explicit id** — `step('id', fn, opts)` → use the string.
2. **Infer from thunk** — `step(() => fn())` or `step(() => deps.fn())` → parse the thunk and use the callee name when possible.
3. **Fallback** — when inference fails (minified code, complex body) → `step_1`, `step_2`, …

So **at runtime and in static docs**, `step('fetchUser', () => fetchUser('1'))` and `step(() => fetchUser('1'))` often yield the same step id/name in events, diagrams, and caching.

<Aside type="tip" title="When to use step('id', fn)">
Use **`step('id', fn, opts)`** when you want a **stable** step id that survives minification or when the thunk body is complex (inference can fail). Use `step(() => fn())` when the thunk clearly calls a single function — awaitly will infer the name at runtime and in generated docs.
</Aside>

<Aside type="tip" title="Early exit">
Unlike try/catch where you need explicit return statements, `step()` automatically exits the workflow on error. The error becomes the workflow's result.
</Aside>

## Using thunks for caching

Pass a function (thunk) instead of calling directly to enable caching:

```typescript
// Without thunk - always executes (legacy form)
const user = await step(fetchUser('1'));

// With thunk - can be cached (prefer named form for static docs)
const user = await step('fetchUser', () => fetchUser('1'), { key: 'user:1' });
```

<Aside type="note">
A thunk is just a function with no arguments that returns the value. Using thunks lets awaitly control when (and whether) to execute the operation.
</Aside>

## Step options

Use the named form and pass options as the third argument:

```typescript
const user = await step('fetchUser', () => fetchUser('1'), {
  key: 'user:1',            // For caching/deduplication
  retry: { attempts: 3 },   // Retry on failure
  timeout: { ms: 5000 },    // Timeout after 5 seconds
  description: 'Load user by ID',  // For generated docs
});
```

With the legacy form `step(fn, opts)`, you can set `name` in options for visualization; with `step('id', fn, opts)` the first argument is the step ID used by tooling.

## step.try - wrap throwing code

Convert exceptions into typed errors:

```typescript
const data = await step.try(
  async () => {
    const res = await fetch('/api/data');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  },
  { error: 'FETCH_FAILED' as const }
);
/*
Output (success):
data contains the parsed JSON

Output (failure):
Workflow returns { ok: false, error: 'FETCH_FAILED' }
*/
```

<Aside type="tip" title="Error type safety">
The `as const` assertion is important. It tells TypeScript this is the literal string `'FETCH_FAILED'`, not just `string`.
</Aside>

The error type is added to the workflow's error union automatically.

## step.fromResult - preserve error details

When your operation returns a Result with rich error objects:

```typescript
type ApiError = { code: number; message: string };

const callApi = async (): AsyncResult<Data, ApiError> => {
  // Returns err({ code: 429, message: 'Rate limited' })
};

const data = await step.fromResult(
  () => callApi(),
  {
    onError: (apiError) => ({
      type: 'API_ERROR' as const,
      ...apiError,
    }),
  }
);
/*
Output (on rate limit):
{ ok: false, error: { type: 'API_ERROR', code: 429, message: 'Rate limited' } }
*/
```

## step.retry - retry with backoff

```typescript
const user = await step.retry(
  () => fetchUser('1'),
  {
    attempts: 3,
    backoff: 'exponential',  // 'fixed' | 'linear' | 'exponential'
    delayMs: 100,            // Base delay
    maxDelayMs: 5000,        // Cap for exponential
    jitter: true,            // Add randomness
    retryOn: (error) => error !== 'NOT_FOUND', // Don't retry NOT_FOUND
  }
);
```

### Backoff strategies visualized

```text
Fixed (delayMs: 100):
#1: 100ms   ████
#2: 100ms   ████
#3: 100ms   ████

Linear (delayMs: 100):
#1: 100ms   ████
#2: 200ms   ████████
#3: 300ms   ████████████

Exponential (delayMs: 100):
#1: 100ms   ████
#2: 200ms   ████████
#3: 400ms   ████████████████
#4: 800ms   ████████████████████████████████
```

<Aside type="note">
Exponential backoff is recommended for network calls. It reduces load on struggling services while still retrying failed operations.
</Aside>

## step.withTimeout - add timeout

```typescript
const data = await step.withTimeout(
  () => slowOperation(),
  {
    ms: 5000,
    name: 'Slow operation', // For error messages
  }
);
/*
Output (completes in time):
data contains the result

Output (times out):
{ ok: false, error: StepTimeoutError }
*/
```

If the timeout is reached, the workflow gets a `StepTimeoutError`.

## Combining retry and timeout

```typescript
const data = await step.retry(
  () => step.withTimeout(() => fetchData(), { ms: 2000 }),
  { attempts: 3, backoff: 'exponential' }
);
```

Each attempt has a 2-second timeout. The whole operation retries up to 3 times.

```text
Timeline:
├── Attempt 1 ──────────────► timeout at 2s
│   wait 100ms
├── Attempt 2 ──────────────► timeout at 2s
│   wait 200ms
├── Attempt 3 ──────────────► timeout at 2s (or success!)
```

## step.sleep - pause execution

Pause execution for a specified duration. Use for intentional delays between operations (rate limiting, polling intervals, debouncing). Respects workflow cancellation.

### Basic usage

```typescript
// String duration
await step.sleep("5s", { name: "rate-limit-delay" });

// Duration object
import { seconds, millis } from 'awaitly/workflow';
await step.sleep(seconds(5), { key: "my-sleep" });
await step.sleep(millis(100));
```

### With options

```typescript
await step.sleep("2s", {
  name: "Polling delay",      // For visualization/logging
  key: "poll-delay",          // For caching/deduplication
  ttl: 5000,                  // Cache TTL in milliseconds
  description: "Wait before next poll attempt",
  signal: controller.signal   // Optional AbortSignal for cancellation
});
```

### Rate limiting example

```typescript
const result = await workflow(async (step) => {
  const data = await step(() => fetchData());
  
  // Respect rate limits - wait 1 second between requests
  await step.sleep("1s", { name: "Rate limit delay" });
  
  const moreData = await step(() => fetchMoreData());
  return { data, moreData };
});
```

### Polling example

```typescript
const result = await workflow(async (step) => {
  let status = await step(() => checkStatus());
  
  // Poll every 2 seconds until complete
  while (status !== "complete") {
    await step.sleep("2s", { name: "Poll interval" });
    status = await step(() => checkStatus());
  }
  
  return status;
});
```

### Cancellation

`step.sleep` supports two cancellation mechanisms:

**Workflow cancellation** - Cancel the entire workflow:

```typescript
const controller = new AbortController();
const workflow = createWorkflow({}, { signal: controller.signal });

const resultPromise = workflow(async (step) => {
  await step.sleep("10s", { name: "Long sleep" });
  return "completed";
});

// Cancel after 1 second
setTimeout(() => controller.abort(), 1000);

const result = await resultPromise;
// result.ok is false, error is WorkflowCancelledError
```

**User-provided signal** - Cancel a specific sleep without affecting the workflow:

```typescript
const result = await run(async (step) => {
  const sleepController = new AbortController();

  // Cancel this specific sleep after 1 second
  setTimeout(() => sleepController.abort(), 1000);

  try {
    await step.sleep("10s", {
      name: "Long sleep",
      signal: sleepController.signal
    });
    return "completed normally";
  } catch {
    // Sleep was cancelled by user signal
    return "sleep cancelled, continuing workflow";
  }
});
```

<Aside type="tip" title="Duration formats">
You can use string durations like `"5s"`, `"100ms"`, `"2m"`, or Duration objects from `awaitly/workflow` like `seconds(5)`, `millis(100)`.
</Aside>

## Parallel steps

Run multiple steps concurrently:

<Tabs>
  <TabItem label="All or nothing">
```typescript
import { allAsync } from 'awaitly';

const result = await workflow(async (step) => {
  const [user, posts, comments] = await step(() =>
    allAsync([
      fetchUser('1'),
      fetchPosts('1'),
      fetchComments('1'),
    ])
  );
  return { user, posts, comments };
});
/*
Output (all succeed):
{ ok: true, value: { user, posts, comments } }

Output (any fails):
{ ok: false, error: <first error> }
*/
```
  </TabItem>
  <TabItem label="Partial success">
```typescript
import { allSettled } from 'awaitly';

const result = await workflow(async (step) => {
  const results = await step(() =>
    Promise.all([
      fetchUser('1'),
      fetchPosts('1'),
      fetchComments('1'),
    ]).then(allSettled)
  );
  // results contains all outcomes, even failures
  return results;
});
```
  </TabItem>
</Tabs>

## Named steps for visualization and static docs

Use **`step('id', fn, opts)`** so step names appear in workflow diagrams and in **statically generated documentation**:

```typescript
const user = await step('fetchUser', () => fetchUser('1'));
const posts = await step('fetchPosts', () => fetchPosts(user.id));
/*
Workflow diagram and generated docs show:
┌─────────────┐     ┌─────────────┐
│ fetchUser   │ ──► │ fetchPosts  │
└─────────────┘     └─────────────┘
*/
```

The string literal ID is extracted by [awaitly-analyze](/docs/guides/static-analysis/) and used in Mermaid diagrams, step tables, and doc generators. With the thunk form `step(() => fetchUser('1'))`, both the analyzer and the runtime infer the label from the callee (`fetchUser`) when possible; when inference fails (e.g. complex body or minified code), the runtime uses `step_1`, `step_2`, etc. You can still set `description` or `markdown` in options for richer docs. See [Documenting workflows](/docs/guides/documenting-workflows/) and [Visualization](/docs/guides/visualization/) for details.

## Step variants at a glance

| Variant | Use when |
|---------|----------|
| `step(fn)` | Operation returns a Result |
| `step.try(fn, opts)` | Operation throws exceptions |
| `step.fromResult(fn, opts)` | Need to transform Result errors |
| `step.retry(fn, opts)` | Operation might fail transiently |
| `step.withTimeout(fn, opts)` | Operation might hang |
| `step.sleep(duration, opts)` | Need intentional delay (rate limiting, polling) |

## Next

[Learn about Workflows →](/foundations/workflows/)
