---
title: Workflows and Steps
description: Compose Result-returning operations with run() and createWorkflow()
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Workflows compose multiple Result-returning operations. The `step()` function unwraps Results automatically. If any step fails, the workflow exits early with that error.

## The step() Function

`step()` is the core of workflow composition. It unwraps a Result, returning the value on success or exiting the workflow on error:

```typescript
import { run } from 'awaitly/run';

const result = await run(async (step) => {
  // If fetchUser returns err('NOT_FOUND'), workflow exits here
  const user = await step('fetchUser', () => fetchUser('123'));

  // This only runs if fetchUser succeeded
  const posts = await step('fetchPosts', () => fetchPosts(user.id));

  return { user, posts };
});

if (result.ok) {
  console.log(result.value.user.name);
} else {
  // result.error is 'NOT_FOUND' | 'FETCH_ERROR'
  console.log('Failed:', result.error);
}
```

```text
Execution flow:

fetchUser('123')
     │
     ├── ok(user) ──► fetchPosts(user.id)
     │                      │
     │                      ├── ok(posts) ──► return { user, posts }
     │                      │
     │                      └── err ──► exit workflow
     │
     └── err ──► exit workflow
```

<Aside type="tip" title="Early exit">
Unlike try/catch where you need explicit return statements, `step()` automatically exits the workflow on error. The error becomes the workflow's result.
</Aside>

## run() - One-Off Workflows

Use `run()` for simple, one-off workflows:

```typescript
import { ok, err, type AsyncResult } from 'awaitly';
import { run } from 'awaitly/run';

const getUser = async (id: string): AsyncResult<User, 'NOT_FOUND'> => {
  const user = await db.find(id);
  return user ? ok(user) : err('NOT_FOUND');
};

const getOrders = async (userId: string): AsyncResult<Order[], 'FETCH_ERROR'> => {
  return ok(await db.orders.findByUser(userId));
};

const result = await run(async (step) => {
  const user = await step('getUser', () => getUser('123'));
  const orders = await step('getOrders', () => getOrders(user.id));
  return { user, orders };
});
```

## createWorkflow() - Reusable Workflows

For reusable workflows with automatic error type inference, use `createWorkflow()`:

<Tabs>
  <TabItem label="With inference">
```typescript
import { ok, err, type AsyncResult } from 'awaitly';
import { createWorkflow } from 'awaitly/workflow';

const fetchUser = async (id: string): AsyncResult<User, 'NOT_FOUND'> => { /* ... */ };
const sendEmail = async (to: string): AsyncResult<void, 'EMAIL_FAILED'> => { /* ... */ };

// Error types inferred from dependencies
const workflow = createWorkflow({ fetchUser, sendEmail });

const result = await workflow(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'));
  await step('sendEmail', () => sendEmail(user.email));
  return user;
});

// result.error is automatically typed as:
// 'NOT_FOUND' | 'EMAIL_FAILED' | UnexpectedError
```
  </TabItem>
  <TabItem label="How it works">
```typescript
// awaitly extracts error types from your dependencies:

fetchUser: AsyncResult<User, 'NOT_FOUND'>
                              ▲
                              │ extracted
                              ▼
sendEmail: AsyncResult<void, 'EMAIL_FAILED'>
                             ▲
                             │ extracted
                             ▼
workflow error = 'NOT_FOUND' | 'EMAIL_FAILED' | UnexpectedError
```
  </TabItem>
</Tabs>

<Aside type="tip" title="Why inference matters">
With automatic inference, you never forget to handle an error type. Add a new dependency, and TypeScript immediately warns you about the new error cases.
</Aside>

<Aside type="caution" title="Return raw values, not Result">
Workflow executors return raw values. awaitly wraps them automatically.
See [Troubleshooting: Double-wrapping](/guides/troubleshooting/#returning-ok-from-workflow-executor-double-wrapping).
</Aside>

## When to Use Each

| Scenario | Use |
|----------|-----|
| One-off workflow | `run()` |
| Reusable workflow | `createWorkflow()` |
| Need automatic error inference | `createWorkflow()` |
| Need caching or resume | `createWorkflow()` |
| Testing with mocks | `run()` |
| Dependencies known at compile time | `createWorkflow()` |
| Dependencies passed as parameters | `run()` |

## Step Options

Give steps names and keys for visualization and caching:

```typescript
const user = await step('fetchUser', () => fetchUser('1'), {
  name: 'Fetch user',       // For visualization/logging
  key: 'user:1',            // For caching/deduplication
  retry: { attempts: 3 },   // Retry on failure
  timeout: { ms: 5000 },    // Timeout after 5 seconds
});
```

### Using Thunks for Caching

Pass a function (thunk) instead of calling directly to enable caching:

```typescript
// With thunk - can be cached (ID required as first argument)
const user = await step('fetchUser', () => fetchUser('1'), { key: 'user:1' });
```

<Aside type="note">
A thunk is a function with no arguments that returns the value. Using thunks lets awaitly control when (and whether) to execute the operation.
</Aside>

## step.try() - Wrap Throwing Code

Convert exceptions into typed errors:

```typescript
const data = await step.try(
  'fetchData',
  async () => {
    const res = await fetch('/api/data');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  },
  { error: 'FETCH_FAILED' as const }
);
```

<Aside type="tip" title="Error type safety">
The `as const` assertion is important. It tells TypeScript this is the literal string `'FETCH_FAILED'`, not just `string`.
</Aside>

The error type is added to the workflow's error union automatically.

## step.fromResult() - Preserve Error Details

When your operation returns a Result with rich error objects:

```typescript
type ApiError = { code: number; message: string };

const callApi = async (): AsyncResult<Data, ApiError> => {
  // Returns err({ code: 429, message: 'Rate limited' })
};

const data = await step.fromResult(
  'callApi',
  () => callApi(),
  {
    onError: (apiError) => ({
      type: 'API_ERROR' as const,
      ...apiError,
    }),
  }
);
// On rate limit: { ok: false, error: { type: 'API_ERROR', code: 429, message: 'Rate limited' } }
```

## step.retry() - Retry with Backoff

```typescript
const user = await step.retry(
  'fetchUser',
  () => fetchUser('1'),
  {
    attempts: 3,
    backoff: 'exponential',  // 'fixed' | 'linear' | 'exponential'
    delayMs: 100,            // Base delay
    maxDelayMs: 5000,        // Cap for exponential
    jitter: true,            // Add randomness
    retryOn: (error) => error !== 'NOT_FOUND', // Don't retry NOT_FOUND
  }
);
```

### Backoff strategies visualized

```text
Fixed (delayMs: 100):
#1: 100ms   ████
#2: 100ms   ████
#3: 100ms   ████

Linear (delayMs: 100):
#1: 100ms   ████
#2: 200ms   ████████
#3: 300ms   ████████████

Exponential (delayMs: 100):
#1: 100ms   ████
#2: 200ms   ████████
#3: 400ms   ████████████████
#4: 800ms   ████████████████████████████████
```

<Aside type="note">
Exponential backoff is recommended for network calls. It reduces load on struggling services while still retrying failed operations.
</Aside>

## step.withTimeout() - Add Timeout

```typescript
const data = await step.withTimeout(
  'slowOp',
  () => slowOperation(),
  { ms: 5000 }
);
/*
Output (completes in time):
data contains the result

Output (times out):
{ ok: false, error: StepTimeoutError }
*/
```

If the timeout is reached, the workflow gets a `StepTimeoutError`.

## Combining retry and timeout

```typescript
const data = await step.retry(
  'fetchData',
  () => step.withTimeout('fetchData', () => fetchData(), { ms: 2000 }),
  { attempts: 3, backoff: 'exponential' }
);
```

Each attempt has a 2-second timeout. The whole operation retries up to 3 times.

```text
Timeline:
├── Attempt 1 ──────────────► timeout at 2s
│   wait 100ms
├── Attempt 2 ──────────────► timeout at 2s
│   wait 200ms
├── Attempt 3 ──────────────► timeout at 2s (or success!)
```

## step.sleep() - Pause Execution

Pause execution for a specified duration. Use for intentional delays between operations (rate limiting, polling intervals, debouncing). Respects workflow cancellation.

### Basic usage

```typescript
// String duration
await step.sleep("rate-limit-delay", "5s");

// Duration object
import { seconds, millis } from 'awaitly/workflow';
await step.sleep("my-sleep", seconds(5));
await step.sleep("short-delay", millis(100));
```

### With options

```typescript
await step.sleep("poll-delay", "2s", {
  key: "poll-delay",          // For caching/deduplication (optional)
  ttl: 5000,                  // Cache TTL in milliseconds
  description: "Wait before next poll attempt",
  signal: controller.signal   // Optional AbortSignal for cancellation
});
```

### Rate limiting example

```typescript
const result = await workflow(async (step) => {
  const data = await step('fetchData', () => fetchData());
  
  // Respect rate limits - wait 1 second between requests
  await step.sleep("rate-limit-delay", "1s");
  
  const moreData = await step('fetchMoreData', () => fetchMoreData());
  return { data, moreData };
});
```

### Polling example

```typescript
const result = await workflow(async (step) => {
  let status = await step('checkStatus', () => checkStatus());
  
  // Poll every 2 seconds until complete
  while (status !== "complete") {
    await step.sleep("poll-interval", "2s");
    status = await step('checkStatus', () => checkStatus());
  }
  
  return status;
});
```

### Cancellation

`step.sleep` supports two cancellation mechanisms:

**Workflow cancellation** - Cancel the entire workflow:

```typescript
const controller = new AbortController();
const workflow = createWorkflow({}, { signal: controller.signal });

const resultPromise = workflow(async (step) => {
  await step.sleep("long-sleep", "10s");
  return "completed";
});

// Cancel after 1 second
setTimeout(() => controller.abort(), 1000);

const result = await resultPromise;
// result.ok is false, error is WorkflowCancelledError
```

**User-provided signal** - Cancel a specific sleep without affecting the workflow:

```typescript
const result = await run(async (step) => {
  const sleepController = new AbortController();

  // Cancel this specific sleep after 1 second
  setTimeout(() => sleepController.abort(), 1000);

  try {
    await step.sleep("long-sleep", "10s", {
      signal: sleepController.signal
    });
    return "completed normally";
  } catch {
    // Sleep was cancelled by user signal
    return "sleep cancelled, continuing workflow";
  }
});
```

<Aside type="tip" title="Duration formats">
You can use string durations like `"5s"`, `"100ms"`, `"2m"`, or Duration objects from `awaitly/workflow` like `seconds(5)`, `millis(100)`.
</Aside>

## Parallel Steps

Run multiple steps concurrently:

<Tabs>
  <TabItem label="All or nothing">
```typescript
import { allAsync } from 'awaitly';

const result = await workflow(async (step) => {
  const [user, posts, comments] = await step('fetchUserData', () =>
    allAsync([
      fetchUser('1'),
      fetchPosts('1'),
      fetchComments('1'),
    ])
  );
  return { user, posts, comments };
});
/*
Output (all succeed):
{ ok: true, value: { user, posts, comments } }

Output (any fails):
{ ok: false, error: <first error> }
*/
```
  </TabItem>
  <TabItem label="Partial success">
```typescript
import { allSettled } from 'awaitly';

const result = await workflow(async (step) => {
  const results = await step('fetchAllSettled', () =>
    Promise.all([
      fetchUser('1'),
      fetchPosts('1'),
      fetchComments('1'),
    ]).then(allSettled)
  );
  // results contains all outcomes, even failures
  return results;
});
```
  </TabItem>
</Tabs>

## Named Steps for Visualization

Give steps names to see them in workflow diagrams:

```typescript
const user = await step('fetchUser', () => fetchUser('1'), { name: 'Fetch user' });
const posts = await step('fetchPosts', () => fetchPosts(user.id), { name: 'Fetch posts' });
/*
Workflow diagram shows:
┌─────────────┐     ┌─────────────┐
│ Fetch user  │ ──► │ Fetch posts │
└─────────────┘     └─────────────┘
*/
```

See [Visualization](/guides/visualization/) for details.

## Workflow Options

### cache

Enable step caching to avoid re-executing completed steps:

```typescript
const workflow = createWorkflow(deps, {
  cache: new Map(),
});

const result = await workflow(async (step) => {
  // This step runs once, even if workflow is called multiple times
  const user = await step('fetchUser', () => fetchUser('1'), { key: 'user:1' });
  return user;
});
```

<Aside type="note">
The `key` option is required for caching. Steps without keys always execute.
</Aside>

### resumeState

Resume a workflow from saved state:

```typescript
const workflow = createWorkflow(deps, {
  resumeState: savedState, // From a previous run
});

const result = await workflow(async (step) => {
  // Cached steps return their saved values
  const user = await step('fetchUser', () => fetchUser('1'), { key: 'user:1' });
  return user;
});
```

See [Persistence](/guides/persistence/) for details.

### streamStore

Enable streaming within workflows:

```typescript
import { createMemoryStreamStore } from 'awaitly/streaming';

const workflow = createWorkflow(deps, {
  streamStore: createMemoryStreamStore(),
});

const result = await workflow(async (step) => {
  const writer = step.getWritable<string>({ namespace: 'tokens' });

  await writer.write('Hello');
  await writer.write(' World');
  await writer.close();
});
```

See [Streaming](/guides/streaming/) for details.

### onEvent

Subscribe to workflow events for logging or visualization:

```typescript
const workflow = createWorkflow(deps, {
  onEvent: (event) => {
    switch (event.type) {
      case 'step_start':
        console.log('Starting:', event.name);
        break;
      case 'step_complete':
        console.log('Completed:', event.name, event.durationMs, 'ms');
        break;
      case 'step_error':
        console.error('Failed:', event.name, event.error);
        break;
    }
  },
});
/*
Output:
Starting: Fetch user
Completed: Fetch user 45 ms
Starting: Send email
Failed: Send email EMAIL_FAILED
*/
```

### strict

Force explicit handling of unexpected errors:

```typescript
const workflow = createWorkflow(deps, {
  strict: true,
  catchUnexpected: (thrown) => ({
    type: 'UNEXPECTED' as const,
    message: String(thrown),
  }),
});
```

### signal (Cancellation)

Cancel workflows externally using an AbortSignal:

```typescript
import { isWorkflowCancelled } from 'awaitly/workflow';

const controller = new AbortController();
const workflow = createWorkflow(deps, {
  signal: controller.signal,
});

// Start workflow
const resultPromise = workflow(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'), { key: 'fetch-user' });
  await step('sendEmail', () => sendEmail(user.email), { key: 'send-email' });
  return user;
});

// Cancel from outside (e.g., timeout, user action)
setTimeout(() => controller.abort('timeout'), 5000);

const result = await resultPromise;
if (!result.ok && isWorkflowCancelled(result.error)) {
  console.log('Cancelled:', result.error.reason);
}
/*
Output (if cancelled):
Cancelled: timeout
*/
```

<Aside type="note" title="When cancellation applies">
- Abort signaled before workflow starts
- Abort occurs between steps
- A step throws `AbortError` (e.g., from `fetch` respecting the signal)
- Abort fires during the last step but the step completes successfully

**Typed errors are preserved:** If a step returns `err("KNOWN_ERROR")` even while abort is signaled, that typed error is returned, not masked as cancellation.
</Aside>

**Passing signal to operations:**

Steps using `step.withTimeout` can receive the workflow signal:

```typescript
const result = await workflow(async (step) => {
  // Signal fires on EITHER timeout OR workflow cancellation
  const data = await step.withTimeout(
    'fetchUrl',
    (signal) => fetch(url, { signal }),
    { ms: 3000, signal: true }
  );
  return data;
});
```

Or access the signal directly via context:

```typescript
const result = await workflow(async (step, deps, ctx) => {
  // Manual signal access
  const response = await fetch(url, { signal: ctx.signal });

  // Check if cancelled
  if (ctx.signal?.aborted) {
    return err('CANCELLED' as const);
  }
  return ok(response);
});
```

## Execution-Time Options

Override options for specific runs with `workflow.run()`:

<Tabs>
  <TabItem label="workflow.run()">
```typescript
const workflow = createWorkflow({ fetchUser }, {
  onEvent: defaultLogger,  // Creation-time default
});

// Normal run - uses creation-time options
await workflow(async (step) => { /* ... */ });

// Per-run options override creation-time
await workflow.run(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'));
  return user;
}, {
  onEvent: vizualizer.handleEvent,  // Override for this run only
  signal: controller.signal,         // Add signal for this run
});
```
  </TabItem>
  <TabItem label="workflow.with()">
```typescript
// Pre-bind options for repeated use
const visualized = workflow.with({
  onEvent: viz.handleEvent,
});

// All calls use viz.handleEvent
await visualized(async (step) => { /* ... */ });
await visualized(async (step) => { /* ... */ });

// Chaining works
const w = workflow
  .with({ onEvent: viz.handleEvent })
  .with({ signal: controller.signal });
```
  </TabItem>
</Tabs>

<Aside type="tip" title="When to use each">
- **`workflow(...)`** - Normal runs with creation-time options
- **`workflow.run(..., exec)`** - One-off runs needing per-run options
- **`workflow.with(exec)`** - Pre-bind options for a category of runs (e.g., all visualized runs)
</Aside>

### Override semantics

Execution-time options override creation-time options:

```typescript
const workflow = createWorkflow(deps, {
  onEvent: handlerA,        // Creation-time
  signal: signalA,
});

// handlerB overrides handlerA for this run
// signalA is NOT used (signalB takes over)
await workflow.run(fn, {
  onEvent: handlerB,        // Wins
  signal: signalB,          // Wins
});

// Back to creation-time defaults
await workflow(fn);  // Uses handlerA, signalA
```

### Available execution options

| Option | Description |
|--------|-------------|
| `onEvent` | Event handler for this run |
| `onError` | Error handler for this run |
| `signal` | AbortSignal for this run |
| `createContext` | Context factory for this run |
| `resumeState` | Resume state for this run (can be async factory) |
| `shouldRun` | Concurrency control hook |
| `onBeforeStart` | Pre-start hook |
| `onAfterStep` | Post-step hook for checkpointing |
| `streamStore` | Stream store for this run |

<Aside type="note">
Options like `cache` and `strict` are **creation-time only**. They define the workflow's fundamental behavior and cannot be changed per-run.
</Aside>

### Merging with `.with()`

When using `.with().run()`, caller options override bound options:

```typescript
const w2 = workflow.with({ onEvent: handlerB });

// handlerC wins (caller overrides bound)
await w2.run(fn, { onEvent: handlerC });
```

## Context

Pass context through workflow execution:

```typescript
const workflow = createWorkflow(deps);

const result = await workflow(
  async (step, context) => {
    console.log('User ID:', context.userId);
    const user = await step('fetchUser', () => fetchUser(context.userId));
    return user;
  },
  { context: { userId: '123', requestId: 'abc' } }
);
/*
Output:
User ID: 123
*/
```

## Composing Workflows

Workflows are just functions. Compose them naturally:

```typescript
const validateInput = createWorkflow({ validateEmail, validatePassword });
const processPayment = createWorkflow({ chargeCard, saveReceipt });

const checkout = createWorkflow({
  validateEmail,
  validatePassword,
  chargeCard,
  saveReceipt,
});

const result = await checkout(async (step) => {
  // Use steps from all dependencies
  await step('validateEmail', () => validateEmail(input.email));
  await step('validatePassword', () => validatePassword(input.password));
  await step('chargeCard', () => chargeCard(input.amount));
  await step('saveReceipt', () => saveReceipt(input.orderId));
});
```

## Step Variants at a Glance

| Variant | Use when |
|---------|----------|
| `step('id', fn)` | Operation returns a Result |
| `step.try(id, fn, opts)` | Operation throws exceptions |
| `step.fromResult(id, fn, opts)` | Need to transform Result errors |
| `step.retry(id, fn, opts)` | Operation might fail transiently |
| `step.withTimeout(id, fn, opts)` | Operation might hang |
| `step.sleep(id, duration, opts)` | Need intentional delay (rate limiting, polling) |

## Complete Example

```typescript
import { ok, err, type AsyncResult } from 'awaitly';
import { createWorkflow } from 'awaitly/workflow';

type User = { id: string; name: string; email: string };
type Post = { id: number; title: string };

const fetchUser = async (id: string): AsyncResult<User, 'NOT_FOUND'> =>
  id === '1' ? ok({ id: '1', name: 'Alice', email: 'alice@example.com' }) : err('NOT_FOUND');

const fetchPosts = async (userId: string): AsyncResult<Post[], 'FETCH_ERROR'> =>
  ok([{ id: 1, title: 'Hello World' }]);

const sendWelcome = async (email: string): AsyncResult<void, 'EMAIL_FAILED'> =>
  ok(undefined);

const onboardUser = createWorkflow({ fetchUser, fetchPosts, sendWelcome });

const result = await onboardUser(async (step) => {
  const user = await step('fetchUser', () => fetchUser('1'));
  const posts = await step('fetchPosts', () => fetchPosts(user.id));
  await step('sendWelcome', () => sendWelcome(user.email));

  return { user, postCount: posts.length };
});

if (result.ok) {
  console.log(`${result.value.user.name} has ${result.value.postCount} posts`);
} else {
  // TypeScript knows all possible errors
  switch (result.error) {
    case 'NOT_FOUND':
      console.log('User not found');
      break;
    case 'FETCH_ERROR':
      console.log('Failed to fetch posts');
      break;
    case 'EMAIL_FAILED':
      console.log('Failed to send welcome email');
      break;
  }
}
```

## Next

[Learn about Control Flow patterns →](/foundations/control-flow/)
