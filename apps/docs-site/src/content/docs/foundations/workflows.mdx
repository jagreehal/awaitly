---
title: Workflows
description: createWorkflow vs run() and when to use each
---

import { Aside } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';

There are two ways to run workflows: `createWorkflow` for reusable workflows with dependency inference, and `run` for one-off operations.

## Type Structure

```text
createWorkflow returns a function that produces:

         ┌─── Your success return type
         │        ┌─── Union of all dependency error types + 'UNEXPECTED_ERROR'
         ▼        ▼
Result<Value, 'NOT_FOUND' | 'EMAIL_FAILED' | 'UNEXPECTED_ERROR'>
           ▲
           └─── Automatically inferred from dependencies!
```

## createWorkflow

Creates a reusable workflow with automatic error type inference from dependencies:

<Tabs>
  <TabItem label="With inference">
```typescript
import { ok, err, type AsyncResult } from 'awaitly';
import { createWorkflow } from 'awaitly/workflow';

const fetchUser = async (id: string): AsyncResult<User, 'NOT_FOUND'> => { /* ... */ };
const sendEmail = async (to: string): AsyncResult<void, 'EMAIL_FAILED'> => { /* ... */ };

// Error types inferred from dependencies
const workflow = createWorkflow('workflow', { fetchUser, sendEmail });

const result = await workflow(async ({ step, deps }) => {
  const user = await step('fetchUser', () => deps.fetchUser('1'));
  await step('sendEmail', () => deps.sendEmail(user.email));
  return user;
});
/*
result.error is automatically typed as:
'NOT_FOUND' | 'EMAIL_FAILED' | 'UNEXPECTED_ERROR'
*/
```
  </TabItem>
  <TabItem label="How it works">
```typescript
// awaitly extracts error types from your dependencies:

fetchUser: AsyncResult<User, 'NOT_FOUND'>
                              ▲
                              │ extracted
                              ▼
sendEmail: AsyncResult<void, 'EMAIL_FAILED'>
                             ▲
                             │ extracted
                             ▼
workflow error = 'NOT_FOUND' | 'EMAIL_FAILED' | 'UNEXPECTED_ERROR'
```
  </TabItem>
</Tabs>

<Aside type="tip" title="Why inference matters">
With automatic inference, you never forget to handle an error type. Add a new dependency, and TypeScript immediately warns you about the new error cases.
</Aside>

<Aside type="caution" title="Return raw values, not Result">
Workflow executors return raw values. awaitly wraps them automatically.
See [Troubleshooting: Double-wrapping](/guides/troubleshooting/#returning-ok-from-workflow-executor-double-wrapping).
</Aside>

### With options

```typescript
const workflow = createWorkflow('workflow', { fetchUser, sendEmail },
  {
    cache: new Map(),                    // Enable step caching
    onEvent: (event) => console.log(event), // Event stream
    streamStore: createMemoryStreamStore(), // Enable streaming
  }
);
```

The value returned by `createWorkflow` has **`name`**, **`deps`**, **`options`**, and **`snapshot`** (plus `getSnapshot()`, `run()`, `with()`, `subscribe()`), so it matches WorkflowClass for inspection and persistence (e.g. `workflow.name`, `workflow.snapshot`).

## run()

For one-off workflows where you specify error types manually:

<Tabs>
  <TabItem label="With ErrorOf (best DX)">
```typescript
import { run } from 'awaitly/run';
import { type Errors } from 'awaitly';

type RunErrors = Errors<[typeof fetchUser, typeof sendEmail]>;
const result = await run<User, RunErrors>(
  async ({ step }) => {
    const user = await step('fetchUser', () => fetchUser('1'));
    await step('sendEmail', () => sendEmail(user.email));
    return user;
  }
);
// result.error is: 'NOT_FOUND' | 'EMAIL_FAILED' | 'UNEXPECTED_ERROR'
```
  </TabItem>
  <TabItem label="With catchUnexpected (custom)">
```typescript
import { run } from 'awaitly/run';

const result = await run<User, 'NOT_FOUND' | 'EMAIL_FAILED'>(
  async ({ step }) => {
    const user = await step('fetchUser', () => fetchUser('1'));
    await step('sendEmail', () => sendEmail(user.email));
    return user;
  },
  { catchUnexpected: (thrown) => ({ type: 'UNEXPECTED' as const, message: String(thrown) }) }
);
// result.error is: 'NOT_FOUND' | 'EMAIL_FAILED' | { type: 'UNEXPECTED', message: string }
```
  </TabItem>
  <TabItem label="Without type params">
```typescript
import { run } from 'awaitly/run';

const result = await run(async ({ step }) => {
  const user = await step('fetchUser', () => fetchUser('1'));
  await step('sendEmail', () => sendEmail(user.email));
  return user;
});
// result.error is: 'UNEXPECTED_ERROR' (step error types not preserved at compile time)
```
  </TabItem>
</Tabs>

<Aside type="tip" title="Deriving error types for run()">
Use `ErrorOf<typeof fn>` for a single dep or `Errors<[typeof fn1, typeof fn2]>` for multiple deps to derive the error union. Your step errors are preserved in the result as `E | 'UNEXPECTED_ERROR'`. Use `catchUnexpected` only when you want a custom unexpected type instead of the default string.
</Aside>

## When to use each

<Tabs>
  <TabItem label="Comparison">
| Scenario | Use |
|----------|-----|
| Dependencies known at compile time | `createWorkflow` |
| Dependencies passed as parameters | `run` |
| Need step caching or resume | `createWorkflow` |
| Need automatic error inference | `createWorkflow` |
| One-off workflow | `run` |
| Testing with mocks | `run` |
  </TabItem>
  <TabItem label="Example: createWorkflow">
```typescript
// Production: dependencies known ahead of time
const checkout = createWorkflow('workflow', { validateOrder,
  processPayment,
  sendConfirmation,
});

// Can reuse with different inputs
await checkout(async ({ step, deps }) => { /* ... */ });
await checkout(async ({ step, deps }) => { /* different flow */ });
```
  </TabItem>
  <TabItem label="Example: run">
```typescript
// Testing: dependencies injected
const mockFetch = async () => ok({ id: '1', name: 'Test' });

const result = await run<User, 'NOT_FOUND'>(async (step) => {
  return await step('mockFetch', () => mockFetch());
});
```
  </TabItem>
</Tabs>

## Workflow options

### cache

Enable step caching to avoid re-executing completed steps:

```typescript
const workflow = createWorkflow('workflow', deps, {
  cache: new Map(),
});

const result = await workflow(async ({ step, deps }) => {
  // This step runs once, even if workflow is called multiple times
  const user = await step('fetchUser', () => deps.fetchUser('1'), { key: 'user:1' });
  return user;
});
/*
First call: fetchUser executes
Second call: returns cached result immediately
*/
```

<Aside type="note">
The `key` option is required for caching. Steps without keys always execute.
</Aside>

### resumeState

Resume a workflow from saved state:

```typescript
const workflow = createWorkflow('workflow', deps, {
  resumeState: savedState, // From a previous run
});

const result = await workflow(async ({ step, deps }) => {
  // Cached steps return their saved values
  const user = await step('fetchUser', () => deps.fetchUser('1'), { key: 'user:1' });
  return user;
});
```

See [Persistence](/guides/persistence/) for details.

### streamStore

Enable streaming within workflows:

```typescript
import { createMemoryStreamStore } from 'awaitly/streaming';

const workflow = createWorkflow('workflow', deps, {
  streamStore: createMemoryStreamStore(),
});

const result = await workflow(async ({ step, deps }) => {
  const writer = step.getWritable<string>({ namespace: 'tokens' });

  await writer.write('Hello');
  await writer.write(' World');
  await writer.close();
});
```

See [Streaming](/guides/streaming/) for details.

### onEvent

Subscribe to workflow events for logging, visualization, or debugging:

```typescript
const workflow = createWorkflow('workflow', deps, {
  onEvent: (event) => {
    switch (event.type) {
      case 'step_start':
        console.log('Starting:', event.name);
        break;
      case 'step_complete':
        console.log('Completed:', event.name, event.durationMs, 'ms');
        break;
      case 'step_error':
        console.error('Failed:', event.name, event.error);
        break;
    }
  },
});
/*
Output:
Starting: Fetch user
Completed: Fetch user 45 ms
Starting: Send email
Failed: Send email EMAIL_FAILED
*/
```

### catchUnexpected (custom unexpected type)

By default, thrown exceptions become the string `"UNEXPECTED_ERROR"`. To replace it with your own type, pass `catchUnexpected`:

<Tabs>
  <TabItem label="Default ('UNEXPECTED_ERROR')">
```typescript
// Default - error union includes 'UNEXPECTED_ERROR' string
const workflow = createWorkflow('workflow', deps);

const result = await workflow(async ({ step, deps }) => { /* ... */ });
// result.error: 'NOT_FOUND' | 'ORDER_FAILED' | 'UNEXPECTED_ERROR'
```
  </TabItem>
  <TabItem label="Custom unexpected type">
```typescript
// Custom unexpected - your shape replaces 'UNEXPECTED_ERROR'
const workflow = createWorkflow('workflow', deps, {
  catchUnexpected: (cause) => ({
    type: 'UNEXPECTED' as const,
    cause
  })
});

const result = await workflow(async ({ step, deps }) => { /* ... */ });
// result.error: 'NOT_FOUND' | 'ORDER_FAILED' | { type: 'UNEXPECTED', cause: unknown }
```
  </TabItem>
  <TabItem label="run() with catchUnexpected">
```typescript
// Works with run() too
const result = await run<User, 'NOT_FOUND' | 'EMAIL_FAILED'>(
  async ({ step }) => {
    const user = await step('fetchUser', () => fetchUser('1'));
    await step('sendEmail', () => sendEmail(user.email));
    return user;
  },
  { catchUnexpected: (cause) => ({ type: 'UNEXPECTED' as const, cause }) }
);
// result.error: 'NOT_FOUND' | 'EMAIL_FAILED' | { type: 'UNEXPECTED', cause: unknown }
```
  </TabItem>
</Tabs>

With `catchUnexpected`:
- Your custom type replaces `"UNEXPECTED_ERROR"` in the error union.
- Use for exhaustive switch statements or when you want a single typed shape for all unexpected cases.

<Aside type="tip" title="When to use catchUnexpected">
Most users don't need `catchUnexpected`. The default `"UNEXPECTED_ERROR"` string works well — it's a simple, predictable value you can check with `result.error === 'UNEXPECTED_ERROR'`. Use `catchUnexpected` only when you need a custom shape (e.g. to include the cause in the error object itself).
</Aside>

### signal (Cancellation)

Cancel workflows externally using an AbortSignal:

```typescript
import { isWorkflowCancelled } from 'awaitly/workflow';

const controller = new AbortController();
const workflow = createWorkflow('workflow', deps, {
  signal: controller.signal,
});

// Start workflow
const resultPromise = workflow(async ({ step, deps }) => {
  const user = await step('fetchUser', () => deps.fetchUser('1'), { key: 'fetch-user' });
  await step('sendEmail', () => deps.sendEmail(user.email), { key: 'send-email' });
  return user;
});

// Cancel from outside (e.g., timeout, user action)
setTimeout(() => controller.abort('timeout'), 5000);

const result = await resultPromise;
if (!result.ok && isWorkflowCancelled(result.cause)) {
  console.log('Cancelled:', result.cause.reason);
}
/*
Output (if cancelled):
Cancelled: timeout
*/
```

<Aside type="note" title="When cancellation applies">
- Abort signaled before workflow starts
- Abort occurs between steps
- A step throws `AbortError` (e.g., from `fetch` respecting the signal)
- Abort fires during the last step but the step completes successfully

**Typed errors are preserved:** If a step returns `err("KNOWN_ERROR")` even while abort is signaled, that typed error is returned, not masked as cancellation. With the default error mapper, check `result.cause` (not `result.error`) for `WorkflowCancelledError` when handling cancellation.
</Aside>

**Passing signal to operations:**

Steps using `step.withTimeout` can receive the workflow signal:

```typescript
const result = await workflow(async ({ step, deps }) => {
  // Signal fires on EITHER timeout OR workflow cancellation
  const data = await step.withTimeout(
    'fetchUrl',
    (signal) => fetch(url, { signal }),
    { ms: 3000, signal: true }
  );
  return data;
});
```

Or access the signal directly via context:

```typescript
const result = await workflow(async ({ step, deps, ctx }) => {
  // Manual signal access
  const response = await fetch(url, { signal: ctx.signal });

  // Check if cancelled
  if (ctx.signal?.aborted) {
    return err('CANCELLED' as const);
  }
  return ok(response);
});
```

## Execution-time options

While `createWorkflow` accepts options at creation time, you may need different options for specific runs. Use `workflow.run()` for per-run configuration:

<Tabs>
  <TabItem label="workflow.run()">
```typescript
const workflow = createWorkflow('workflow', { fetchUser }, {
  onEvent: defaultLogger,  // Creation-time default
});

// Normal run - uses creation-time options
await workflow(async ({ step, deps }) => { /* ... */ });

// Per-run options override creation-time
await workflow.run(async ({ step, deps }) => {
  const user = await step('fetchUser', () => deps.fetchUser('1'));
  return user;
}, {
  onEvent: vizualizer.handleEvent,  // Override for this run only
  signal: controller.signal,         // Add signal for this run
});
```
  </TabItem>
  <TabItem label="workflow.with()">
```typescript
// Pre-bind options for repeated use
const visualized = workflow.with({
  onEvent: viz.handleEvent,
});

// All calls use viz.handleEvent
await visualized(async ({ step, deps }) => { /* ... */ });
await visualized(async ({ step, deps }) => { /* ... */ });

// Chaining works
const w = workflow
  .with({ onEvent: viz.handleEvent })
  .with({ signal: controller.signal });
```
  </TabItem>
</Tabs>

<Aside type="tip" title="When to use each">
- **`workflow(...)`** - Normal runs with creation-time options
- **`workflow.run(..., exec)`** - One-off runs needing per-run options
- **`workflow.with(exec)`** - Pre-bind options for a category of runs (e.g., all visualized runs)
</Aside>

### Override semantics

Execution-time options override creation-time options:

```typescript
const workflow = createWorkflow('workflow', deps, {
  onEvent: handlerA,        // Creation-time
  signal: signalA,
});

// handlerB overrides handlerA for this run
// signalA is NOT used (signalB takes over)
await workflow.run(fn, {
  onEvent: handlerB,        // Wins
  signal: signalB,         // Wins
});

// Back to creation-time defaults
await workflow(fn);  // Uses handlerA, signalA
```

### Available execution options

| Option | Description |
|--------|-------------|
| `onEvent` | Event handler for this run |
| `onError` | Error handler for this run |
| `signal` | AbortSignal for this run |
| `createContext` | Context factory for this run |
| `resumeState` | Resume state for this run (can be async factory) |
| `shouldRun` | Concurrency control hook |
| `onBeforeStart` | Pre-start hook |
| `onAfterStep` | Post-step hook for checkpointing |
| `streamStore` | Stream store for this run |

<Aside type="note">
Options like `cache` and `catchUnexpected` are **creation-time only**. They define the workflow's fundamental behavior and cannot be changed per-run.
</Aside>

### Merging with `.with()`

When using `.with().run()`, caller options override bound options:

```typescript
const w2 = workflow.with({ onEvent: handlerB });

// handlerC wins (caller overrides bound)
await w2.run(fn, { onEvent: handlerC });
```

## Composing workflows

Workflows are just functions. Compose them naturally:

```typescript
const validateInput = createWorkflow('workflow', { validateEmail, validatePassword });
const processPayment = createWorkflow('workflow', { chargeCard, saveReceipt });

const checkout = createWorkflow('workflow', { validateEmail,
  validatePassword,
  chargeCard,
  saveReceipt,
});

const result = await checkout(async ({ step, deps }) => {
  // Use steps from all dependencies
  await step('validateEmail', () => deps.validateEmail(input.email));
  await step('validatePassword', () => deps.validatePassword(input.password));
  await step('chargeCard', () => deps.chargeCard(input.amount));
  await step('saveReceipt', () => deps.saveReceipt(input.orderId));
});
```

## Workflow input (args)

Pass input to a workflow as a single object. The callback receives it as `args`:

```typescript
const workflow = createWorkflow('workflow', deps);

const result = await workflow(
  { userId: '123', requestId: 'abc' },
  async ({ step, deps, args }) => {
    console.log('User ID:', args.userId);
    const user = await step('fetchUser', () => deps.fetchUser(args.userId));
    return user;
  }
);
/*
Output:
User ID: 123
*/
```

<Aside type="tip" title="Callback context">
The workflow callback always receives one argument: a context object `{ step, deps, args?, ctx }`. When you pass input, call `workflow(args, fn)` with **args as an object**; it appears as `args` in the callback. Per-run execution context (e.g. for events) is set via `createContext` in options or `workflow.run(fn, { createContext })`, and is available as `ctx`.
</Aside>

## Next

[Learn about Tagged Errors →](/foundations/tagged-errors/)
