---
title: State and Resumption
description: Persist workflow state and resume after crashes
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

awaitly can save workflow state and resume from where it left off. This enables crash recovery, long-running workflows, and idempotent operations.

<Aside type="caution" title="Options go to createWorkflow">
Options like `resumeState` and `cache` must be passed to `createWorkflow(deps, { resumeState })`, not when calling the workflow.
</Aside>

## Step Caching

Enable caching so steps don't re-execute:

```typescript
const workflow = createWorkflow(deps, {
  cache: new Map(),
});

const result = await workflow(async (step) => {
  // Cached with key 'user:1'
  const user = await step(() => fetchUser('1'), { key: 'user:1' });
  return user;
});
```

### Key Requirements

Keys must be:
- **Unique per step**: Different steps need different keys
- **Stable**: Same input should produce same key
- **Deterministic**: No timestamps or random values

```typescript
// Good keys
{ key: 'user:123' }
{ key: `posts:${userId}` }
{ key: `order:${orderId}:validate` }

// Bad keys
{ key: `user:${Date.now()}` }      // Changes every call
{ key: `user:${Math.random()}` }   // Random
```

### Thunks Required for Caching

Pass a function, not the result of calling:

```typescript
// Without thunk - executes immediately, caching ignored
const user = await step(fetchUser('1'), { key: 'user:1' });

// With thunk - can be cached
const user = await step(() => fetchUser('1'), { key: 'user:1' });
```

### Cache Scope

The cache persists across workflow runs:

```typescript
const cache = new Map();
const workflow = createWorkflow(deps, { cache });

// First run - fetches user
await workflow(async (step) => {
  const user = await step(() => fetchUser('1'), { key: 'user:1' });
  return user;
});

// Second run - uses cached value (no fetch)
await workflow(async (step) => {
  const user = await step(() => fetchUser('1'), { key: 'user:1' });
  return user;
});
```

## Collecting State for Persistence

Use `createResumeStateCollector` to capture step results:

```typescript
import { createWorkflow, createResumeStateCollector } from 'awaitly/workflow';

const collector = createResumeStateCollector();

const workflow = createWorkflow(
  { fetchUser, fetchPosts },
  { onEvent: collector.handleEvent }
);

await workflow(async (step) => {
  const user = await step(() => fetchUser('1'), { key: 'user:1' });
  const posts = await step(() => fetchPosts(user.id), { key: `posts:${user.id}` });
  return { user, posts };
});

// Get collected state
const state = collector.getResumeState();
```

<Aside type="note">
Only steps with `key` are saved. Steps without keys always execute.
</Aside>

## Serializing State

<Aside type="danger" title="Always use stringifyState/parseState">
`ResumeState.steps` is a `Map`, which **cannot be serialized with `JSON.stringify()`**. Maps become empty objects `{}` when serialized directly!
</Aside>

```typescript
import { stringifyState, parseState } from 'awaitly/persistence';

// Serialize for storage
const json = stringifyState(state, {
  workflowId: 'wf-123',
  timestamp: Date.now(),
});

await db.workflowStates.create({
  id: 'wf-123',
  state: json,
  createdAt: new Date(),
});

// Later: deserialize
const saved = await db.workflowStates.findUnique({ where: { id: 'wf-123' } });
const resumeState = parseState(saved.state);
```

## Resuming Workflows

Pass saved state to a new workflow:

```typescript
import { parseState } from 'awaitly/persistence';

const saved = await db.workflowStates.findUnique({ where: { id: 'wf-123' } });
const resumeState = parseState(saved.state);

const workflow = createWorkflow(
  { fetchUser, fetchPosts },
  { resumeState }
);

await workflow(async (step) => {
  // These steps return cached values - no actual fetch
  const user = await step(() => fetchUser('1'), { key: 'user:1' });
  const posts = await step(() => fetchPosts(user.id), { key: `posts:${user.id}` });
  return { user, posts };
});
```

### Async Resume State Loading

Load state lazily:

```typescript
const workflow = createWorkflow(deps, {
  resumeState: async () => {
    const saved = await db.workflowStates.findUnique({ where: { id: 'wf-123' } });
    return saved ? parseState(saved.state) : undefined;
  },
});
```

## Crash Recovery Pattern

Save state after each batch of work:

```typescript
const collector = createResumeStateCollector();
const workflow = createWorkflow(deps, { onEvent: collector.handleEvent });

const result = await workflow(async (step) => {
  const user = await step(() => fetchUser('1'), { key: 'user:1' });

  // Save after critical step
  await saveCheckpoint('wf-123', collector.getResumeState());

  const posts = await step(() => fetchPosts(user.id), { key: `posts:${user.id}` });
  return { user, posts };
});

// Final save
await saveCheckpoint('wf-123', collector.getResumeState());
```

If the workflow crashes, resume from the last checkpoint:

```typescript
const savedState = await loadCheckpoint('wf-123');

const workflow = createWorkflow(deps, { resumeState: savedState });

await workflow(async (step) => {
  // Completed steps use cached values
  const user = await step(() => fetchUser('1'), { key: 'user:1' });
  const posts = await step(() => fetchPosts(user.id), { key: `posts:${user.id}` });
  return { user, posts };
});
```

## Checking Step Completion

Check if a step is already complete before execution:

```typescript
import { isStepComplete } from 'awaitly/workflow';

const state = await loadCheckpoint('wf-123');

if (isStepComplete(state, 'user:1')) {
  console.log('User already fetched');
}
```

## State Persistence Adapter

For structured storage, use `createStatePersistence`:

```typescript
import { createStatePersistence } from 'awaitly/persistence';

const persistence = createStatePersistence({
  get: (key) => redis.get(key),
  set: (key, value) => redis.set(key, value),
  delete: (key) => redis.del(key).then(n => n > 0),
  exists: (key) => redis.exists(key).then(n => n > 0),
  keys: (pattern) => redis.keys(pattern),
}, 'workflow:state:');

// Save
await persistence.save('wf-123', state, { userId: 'user-1' });

// Load
const savedState = await persistence.load('wf-123');

// Resume
const workflow = createWorkflow(deps, { resumeState: savedState });
```

## File-Based Persistence

For simple cases:

```typescript
import { createFileCache } from 'awaitly/persistence';

const cache = createFileCache({
  directory: './workflow-state',
  ttlMs: 7 * 24 * 60 * 60 * 1000, // 7 days
});

const workflow = createWorkflow(deps, { cache });
```

## Idempotency Keys

Use step keys for idempotent operations:

```typescript
const result = await workflow(async (step) => {
  // Payment only processes once, even on retry
  const payment = await step(
    () => processPayment(orderId, amount),
    { key: `payment:${orderId}` }
  );

  return payment;
});
```

<Aside type="tip" title="Critical operations">
Always use unique, stable keys for operations that shouldn't repeat:
- Payments
- Email sending
- External API calls with side effects
</Aside>

## Error Caching

Errors are cached by default. If a step fails, subsequent runs return the same error:

```typescript
// First run - fetchUser returns err('NOT_FOUND')
await workflow(async (step) => {
  const user = await step(() => fetchUser('999'), { key: 'user:999' });
  return user;
});
// result.error === 'NOT_FOUND'

// Second run - returns cached error (no fetch)
await workflow(async (step) => {
  const user = await step(() => fetchUser('999'), { key: 'user:999' });
  return user;
});
// result.error === 'NOT_FOUND' (from cache)
```

To retry on error, clear the cache key first:

```typescript
cache.delete('user:999');
```

## When to Use Caching

| Use Case | Caching Helps |
|----------|--------------|
| Idempotent operations | Yes - payments, API calls |
| Resume after crash | Yes - completed steps skipped |
| Expensive computations | Yes - don't recompute |
| Time-sensitive data | No - data may be stale |
| Non-idempotent operations | Careful - may cause issues |

## Complete Example

```typescript
import { createWorkflow, createResumeStateCollector } from 'awaitly/workflow';
import { stringifyState, parseState, createStatePersistence } from 'awaitly/persistence';

// Setup persistence
const persistence = createStatePersistence({
  get: (key) => db.get(key),
  set: (key, value) => db.set(key, value),
  delete: (key) => db.delete(key),
  exists: (key) => db.exists(key),
  keys: (pattern) => db.keys(pattern),
}, 'workflow:');

// Run with checkpoint saves
async function runWithRecovery(workflowId: string) {
  const savedState = await persistence.load(workflowId);
  const collector = createResumeStateCollector();

  const workflow = createWorkflow(
    { fetchUser, processPayment, sendConfirmation },
    {
      resumeState: savedState,
      onEvent: collector.handleEvent,
    }
  );

  const result = await workflow(async (step) => {
    const user = await step(
      () => fetchUser('1'),
      { key: 'user:1' }
    );

    // Checkpoint after user fetch
    await persistence.save(workflowId, collector.getResumeState());

    const payment = await step(
      () => processPayment(user.id, 100),
      { key: `payment:${user.id}` }
    );

    // Checkpoint after payment
    await persistence.save(workflowId, collector.getResumeState());

    await step(
      () => sendConfirmation(user.email, payment.id),
      { key: `confirm:${payment.id}` }
    );

    return { user, payment };
  });

  // Final save
  await persistence.save(workflowId, collector.getResumeState());

  return result;
}
```

## Next

[Learn about Streaming â†’](/foundations/streaming/)
