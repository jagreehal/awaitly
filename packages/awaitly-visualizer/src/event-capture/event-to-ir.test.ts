/**
 * Events -> IR tree correctness tests.
 *
 * Verifies that the IR builder produces correct tree structure
 * from events generated by the kitchen-sink workflow.
 */

import { describe, it, expect, beforeEach } from "vitest";
import type { WorkflowEvent } from "awaitly/workflow";
import {
  createVisualizer,
  isParallelNode,
  isRaceNode,
  isDecisionNode,
  isStepNode,
  type FlowNode,
  type CollectableEvent,
  type DecisionStartEvent,
  type DecisionBranchEvent,
  type DecisionEndEvent,
} from "../index";
import {
  runProcessOrder,
  runProcessOrderError,
  runProcessOrderWithHooks,
  resetChargeCardAttempt,
} from "./kitchen-sink-workflow";

describe("event-to-ir: Events -> IR tree", () => {
  beforeEach(() => {
    resetChargeCardAttempt();
  });

  function createVizAndCollect() {
    const viz = createVisualizer({
      workflowName: "processOrder",
      detectParallel: false,
    });
    const decisionEvents: CollectableEvent[] = [];

    return {
      viz,
      onEvent: viz.handleEvent as (event: WorkflowEvent<unknown>) => void,
      onDecisionEvent: (e: CollectableEvent) => {
        decisionEvents.push(e);
        if (e.type.startsWith("decision_")) {
          viz.handleDecisionEvent(e as DecisionStartEvent | DecisionBranchEvent | DecisionEndEvent);
        }
      },
      decisionEvents,
    };
  }

  // =========================================================================
  // Happy Path IR Structure
  // =========================================================================

  describe("happy path IR", () => {
    it("IR root has type=workflow, state=success, name=processOrder", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      expect(ir.root.type).toBe("workflow");
      expect(ir.root.state).toBe("success");
      expect(ir.root.name).toBe("processOrder");
    });

    it("child count matches expected top-level nodes", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      // Expected nodes: fetchCart, validateOrder(parallel), isPremium(decision),
      // paymentMethod(decision), chargeCard, shippingEstimate(race),
      // bundleDiscount, reserveShipping, sendNotifications(parallel), finalizeOrder
      expect(ir.root.children.length).toBeGreaterThanOrEqual(8);
    });

    it("ParallelNode found with mode=all for validateOrder", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      const parallelNode = ir.root.children.find(
        (n) => isParallelNode(n) && n.name === "validateOrder"
      );
      expect(parallelNode).toBeDefined();
      if (parallelNode && isParallelNode(parallelNode)) {
        expect(parallelNode.mode).toBe("all");
      }
    });

    it("RaceNode found for shippingEstimate", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      const raceNode = ir.root.children.find(
        (n) => isRaceNode(n) && n.name === "shippingEstimate"
      );
      expect(raceNode).toBeDefined();
      if (raceNode && isRaceNode(raceNode)) {
        expect(raceNode.type).toBe("race");
      }
    });

    it("DecisionNode found with correct branches for isPremium", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      const decisionNode = ir.root.children.find(
        (n) => isDecisionNode(n) && n.id === "isPremium"
      );
      expect(decisionNode).toBeDefined();
      if (decisionNode && isDecisionNode(decisionNode)) {
        expect(decisionNode.branches.length).toBe(2);
        const ifBranch = decisionNode.branches.find((b) => b.label === "if");
        const elseBranch = decisionNode.branches.find((b) => b.label === "else");
        expect(ifBranch).toBeDefined();
        expect(elseBranch).toBeDefined();
        // isPremium is true (total=125 > 100), so "if" is taken
        expect(ifBranch?.taken).toBe(true);
        expect(elseBranch?.taken).toBe(false);
      }
    });

    it("DecisionNode found with branches for paymentMethod switch", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      const switchNode = ir.root.children.find(
        (n) => isDecisionNode(n) && n.id === "paymentMethod"
      );
      expect(switchNode).toBeDefined();
      if (switchNode && isDecisionNode(switchNode)) {
        expect(switchNode.branches.length).toBe(3);
        const cardBranch = switchNode.branches.find((b) => b.label === "case 'card'");
        expect(cardBranch?.taken).toBe(true);
      }
    });

    it("step nodes have state, durationMs, name fields", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      const fetchCartNode = ir.root.children.find(
        (n) => isStepNode(n) && n.name === "fetchCart"
      );
      expect(fetchCartNode).toBeDefined();
      if (fetchCartNode && isStepNode(fetchCartNode)) {
        expect(fetchCartNode.state).toBe("success");
        expect(fetchCartNode.durationMs).toBeGreaterThanOrEqual(0);
        expect(fetchCartNode.name).toBe("fetchCart");
      }
    });

    it("retry step has retryCount >= 1", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      const chargeCardNode = ir.root.children.find(
        (n) => isStepNode(n) && n.name === "chargeCard"
      );
      expect(chargeCardNode).toBeDefined();
      if (chargeCardNode && isStepNode(chargeCardNode)) {
        expect(chargeCardNode.retryCount).toBeGreaterThanOrEqual(1);
        expect(chargeCardNode.state).toBe("success");
      }
    });

    it("skipped steps have state=skipped", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({ singleItem: true }, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      const skippedNode = ir.root.children.find(
        (n) => isStepNode(n) && n.state === "skipped"
      );
      expect(skippedNode).toBeDefined();
      if (skippedNode && isStepNode(skippedNode)) {
        expect(skippedNode.name).toBe("bundleDiscount");
      }
    });
  });

  // =========================================================================
  // Error Path IR Structure
  // =========================================================================

  describe("error path IR", () => {
    it("root.state=error for error workflow", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrderError({ onEvent, onDecisionEvent });

      const ir = viz.getIR();
      expect(ir.root.state).toBe("error");
    });

    it("root.error is defined for error workflow", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrderError({ onEvent, onDecisionEvent });

      const ir = viz.getIR();
      expect(ir.root.error).toBeDefined();
    });

    it("failing step node has state=error", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrderError({ onEvent, onDecisionEvent });

      const ir = viz.getIR();
      const errorNode = ir.root.children.find(
        (n) => isStepNode(n) && n.state === "error"
      );
      expect(errorNode).toBeDefined();
    });
  });

  // =========================================================================
  // Hooks IR
  // =========================================================================

  describe("hooks IR", () => {
    it("hooks reflected in ir.hooks when configured", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrderWithHooks({ onEvent, onDecisionEvent });

      const ir = viz.getIR();
      expect(ir.hooks).toBeDefined();
      if (ir.hooks) {
        expect(ir.hooks.shouldRun).toBeDefined();
        expect(ir.hooks.onBeforeStart).toBeDefined();
      }
    });
  });

  // =========================================================================
  // Metadata
  // =========================================================================

  describe("metadata", () => {
    it("IR has metadata with createdAt and lastUpdatedAt", async () => {
      const { viz, onEvent, onDecisionEvent } = createVizAndCollect();
      await runProcessOrder({}, { onEvent, onDecisionEvent });

      const ir = viz.getIR();
      expect(ir.metadata).toBeDefined();
      expect(ir.metadata.createdAt).toBeGreaterThan(0);
      expect(ir.metadata.lastUpdatedAt).toBeGreaterThanOrEqual(ir.metadata.createdAt);
    });
  });
});
